<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="balisage-1-3.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-stylesheet type="text/xsl" href="balisage-proceedings-html.xsl"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Patterns and antipatterns in micropipelining within XSLT</title>
  <info>
    <abstract>
      <para>This report explores patterns and antipatterns for pipelining within an XSLT stylesheet.
        The program logic of pipelining can often be expressed most directly by nesting functions
        within one another, but code that depends on nested functions may quickly become unreadable,
        especially if the number of functions is large or if they accept multiple parameters. This
        report examines alternative structural and syntactic expressions for processing
        pipelines.</para>
    </abstract>
    <author>
      <personname>
        <firstname>David</firstname>
        <othername>J.</othername>
        <surname>Birnbaum</surname>
      </personname>
      <personblurb>
        <para>David J. Birnbaum is Professor and Chair of the Department of Slavic Languages and
          Literatures at the University of Pittsburgh. He has been involved in the study of
          electronic text technology since the mid-1980s, has delivered presentations at a variety
          of electronic text technology conferences, and has served on the board of the Association
          for Computers and the Humanities, the editorial board of <emphasis role="ital">Markup
            languages: Theory and practice</emphasis>, and the Text Encoding Initiative Council.
          Much of his electronic text work intersects with his research in medieval Slavic
          manuscript studies, but he also often writes about issues in the philosophy of
          markup.</para>
      </personblurb>
      <affiliation>
        <jobtitle>Professor and Chair</jobtitle>
        <orgname>Department of Slavic Languages and Literatures, University of Pittsburgh</orgname>
      </affiliation>
      <email>djbpitt@gmail.com</email>
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest"
        >http://www.obdurodon.org</link>
    </author>
    <keywordset role="author">
      <keyword>pipeline</keyword>
    </keywordset>
  </info>
  <section>
    <title>Pipelining and micropipelining</title>
    <para><emphasis role="bold">Pipelining</emphasis> describes the process of using the output of a
      function or other operation as the input to a subsequent function or other operation. As an
      example of a function pipeline, if we wish to convert a string to upper case and normalize
      white space within it, we can pass our original input string through a pipeline that combines
      the XPath <code>upper-case()</code> and <code>normalize-space()</code> functions in either
      order. If our original input string reads <quote>Hi,&#xa0;&#xa0;Mom!</quote> (with two spaces
      between the words), we can first apply the <code>upper-case()</code> function (yielding
        <quote>HI,&#xa0;&#xa0;MOM!</quote>, still with two spaces between the words) and then use
      the output of applying the <code>upper-case()</code> function as input into the
        <code>normalize-space()</code> function, which collapses the two consecutive space
      characters into one. Or we can apply the functions in the opposite order. In this example and
      many other pipelines, the order in which the functions are applied does not affect the result;
      for situations where it does, see the discussion of feeding and bleeding orders, below.</para>
    <para>Pipelines may connect small, individual functions, as in the example above, or they may be
      constructed at higher levels. For example, an XSLT transformation might be designed as a
      pipeline of XSLT stylesheets, where the original input XML is passed into a transformation
      that uses one stylesheet and creates output XML, which becomes the input XML for another
      stylesheet, etc., until eventually the desired final output is created. While <emphasis
        role="bold">pipelining</emphasis> is well established as a technical term, <emphasis
        role="bold">micropipelining</emphasis> is less so, and we use it in this report to refer to
      pipelines that operate entirely within a single XSLT stylesheet, whether at the level of
      individual functions or in some of the more complex ways described below.</para>
    <para>Pipes and pipelines trace their popularity as a process-control architecture to a 1964
      typed note by Doug McIlroy about Unix. In a summary of <quote>what’s most important</quote>,
      McIlroy writes that that <quote>[w]e should have some ways of coupling programs like garden
        hose—screw in another segment when it becomes necessary to massage data in another
        way</quote>. (<xref linkend="mcilroy_1964"/>) As for pipelines in an XSLT and XQuery context:<blockquote>
        <para>Constructing an application in the form of a pipeline has many advantages, the main
          ones being (a) that the code of each step in the pipeline is kept very simple; (b) that it
          is very easy to assemble an application from a set of components, thus maximizing the
          potential for component reuse, and (c) there is no requirement that each step in a
          pipeline should use the same technology; it's easy to mix XSLT, XQuery, Java and so on in
          different stages.</para>
        <para>A number of products are available to assist with the development and management of
          pipeline-based applications, examples being Orbeon [Orbeon] and Apache Cocoon [Cocoon].
          More recently W3C has developed a standard language, XProc [W3C XProc], for the definition
          of pipelines. (<xref linkend="kay_2009"/>)</para>
      </blockquote></para>
    <para>Beyond using the output of one process as input to the next, pipelining invites
      computational efficiency by making it possible to stream the flow of information, potentially
      avoiding the overhead of building complete intermediate structures in memory or writing
      intermediate output of the first process to disk and then reading it from disk into the input
      of the next process. Whether an application takes advantage of this possibility depends on the
      implementation (and not all operations are streamable), but although pipelining is similar in
      some respects (especially pertaining to the eventual final output) to saving and reusing
      intermediate results, in a functional environment that supports streaming and multiprocessing,
      it also has the potential of offering performance benefits by eschewing the creation of
      intermediate storage objects in variables or in disk files and permitting data to be processed
      as soon as it and a processing core become available.</para>
  </section>
  <section>
    <title>Patterns and antipatterns</title>
    <para>The term <emphasis role="bold">pattern</emphasis> refers to a generalizable way of
      addressing a common and generalizable type of problem. It is used widely in object-oriented
      programming (see, for example, <xref linkend="gamma_1994"/>), but it is not restricted to that
      domain, and in this presentation the generalizable problem we care about is pipelining in
      XSLT, and the generalizable strategies that are commonly employed to deal with it are our
      patterns. The term <emphasis role="bold">antipattern</emphasis> was introduced by Andrew
      Koenig in 1995 to describe something that looks like a paradigm for a solution to a common
      type of problem, that is, a pattern, but that for structural reasons leads to results that do
      not live up to <quote>best practice</quote> expectations. (<xref linkend="koenig_1995"/>) As
      used in this report, the distinction between patterns and antipatterns helps us focus on the
      strengths and weaknesses of alternative strategies for pipelining within XSLT.</para>
    <para>It is often said that code is read more often than it is written, and from that
      perspective, legibility, which contributes to ease of maintenance, is one feature that can
      distinguish patterns from antipatterns. Another is computational complexity, and in that
      context scalability is another such feature (but see immediately below).<footnote>
        <para>Donald Knuth’s oft-cited statement that <quote>premature optimization is the root of
            all evil</quote> does not blanketly disparage optimization. In narrow context it reads: <blockquote>
            <para>Programmers waste enormous amounts of time thinking about, or worrying about, the
              speed of noncritical parts of their programs, and these attempts at efficiency
              actually have a strong negative impact when debugging and maintenance are considered.
              We <emphasis role="ital">should</emphasis> forget about small efficiencies, say about
              97% of the time: premature optimization is the root of all evil.</para>
            <para>Yet we should not pass up our opportunities in that critical 3%. (<xref
                linkend="knuth_1974"/>, p. 268; see also the larger context on that page)</para>
          </blockquote></para>
      </footnote> Michael Kay, in a discussion of Jackson Structured Programming, writes that
        <quote>[t]he essential principle of JSP was the idea that the structure of the program
        should mirror the structure of the data</quote>, continuing that JSP can contribute to both
      code legibility and maintenance, on the one hand, and operational efficiency, on the other: </para>
    <blockquote>
      <para>[T]he user achieves the benefits that come from writing the application as a controlling
        application (maintainability, readability, reusability) combining these with the
        improvements in system performance that come from using a push-based control model. (<xref
          linkend="kay_2009"/>)</para>
    </blockquote>
    <para>The boundary between a pattern and an antipattern is not always unambiguous. Some
      programming strategies discussed below, such as nested functions, are easy to write and read
      in simple situations (e.g., two functions, each of which takes one parameter), but may scale
      poorly with respect to legibility as the complexity of the context increases. Such models
      might therefore be sensible patterns when applied in those simpler situations, while
      transforming themselves gradually into antipatterns as the complexity of the context
      increases. Scalability may be a useful feature in a pattern, but the strategy that outperforms
      others with <quote>big data</quote> is not necessarily optimal in contexts where the data
      never grow very large . For that reason, the discussion below avoids labeling specific
      solutions globally as pattern or antipattern, and instead discusses both the strengths and
      weaknesses of each approach, with attention to the programming context. We thus use pattern
      and antipattern as a framework for evaluating the strengths and weaknesses of coding
      strategies, rather than as a taxonomy for classifying them in a binary fashion.</para>
  </section>
  <section>
    <title>Micropipelining in context</title>
    <para>Pipelining may play a role in XSLT development at at least three levels: 1) internally,
      within the XSLT processor; 2) between or across stylesheets; and 3) within a single
      stylesheet. We describe these below by way of providing a broad context and overview, but the
      focus of this report is on only the last of the three, on pipelining within a single XSLT
      stylesheet, which we call micropipelining.</para>
    <section>
      <title>1. Pipelining within the XSLT processor</title>
      <para>To the typical XSLT developer, pipelining within the XSLT processor is a black box. Not
        only can optimizations within an XSLT processor transform XSLT instructions into internal
        operations that achieve the same results by following different execution logic, but the
        largely declarative XSLT programming paradigm means that the order employed by the processor
        to execute parts of a transformation is not entirely under the control of the XSLT
        developer. Among other thigs, these properties enable an XSLT processor to improve
        performance by executing operations in parallel, a feature with consequences that sometimes
        surprise XSLT developers who may still be thinking within an imperative paradigm. For
        example, every new XSLT programmer has tried at some point to profile a stylesheet by
        inserting the <code>current-dateTime()</code> or <code>current-time()</code> function before
        and after an operation of interest, only to be surprised when the operation appears to take
        no time at all! This happens because there is no promise in the XSLT processing model that
        these functions will be executed in the order in which they appear in the XSLT code, and for
        that reason XSLT was designed to follow a functional programming paradigm here:<blockquote>
          <para>In XSLT 2.0 it is defined that multiple calls on <code>current-dateTime()</code> and
            the other two [time and date] functions will return the same result every time they are
            called within a single transformation. This means that you can’t call the function at
            the beginning and end of the transformation to measure the elapsed time. The reason for
            this rule is that XSLT is rather purist about being a strictly functional language, and
            in a strictly functional language, calling the same function twice with the same
            arguments always returns the same result. This property makes life much simpler for
            optimizers. (<xref linkend="kay_2009"/>, p. 738)</para>
        </blockquote></para>
      <para>The functional nature of XSLT means that although an XSLT developer might write code
        that is amenable to pipelined execution, how the pipeline is executed is at least partially
        dependent on processor-internal code to which the XSLT developer has no direct access.
        Michael Kay’s alliteratively titled <quote>You pull, I’ll push: on the polarity of
          pipelines</quote>, cited above, continues that:<blockquote>
          <para>For performance, the stages of a pipeline should communicate by means of streams of
            events. Traditionally, this can be done either by writing components with pull polarity
            (the consumer calls the supplier when data is required), or by components with push
            polarity (the supplier calls the consumer when data is available). <emphasis role="ital"
              >Performance problems arise when components with different polarity are mixed within
              the same pipeline.</emphasis> (<xref linkend="kay_2009"/>, emphasis added)</para>
        </blockquote></para>
      <para>As important as this polarity is for performance, to the extent that it is determined
        within the XSLT processor, rather than within the XSLT code, it is at least partially
        outside the control of the XSLT developer. For that reason, in this XSLT-developer-focused
        report, pipelining within the XSLT processor will not be discussed further.</para>
    </section>
    <section>
      <title>2. Pipelining between and across XSLT stylesheets</title>
      <para>Pipelining between or across XSLT stylesheets is much more under the control of the XSLT
        developer. A complex transformation might be broken down into simpler stages, where each
        stage is implemented in a separate XSLT stylesheet, and interim results are written to disk
        by one process and then read from disk by another. This strategy may make the individual
        stylesheets easier to read because each may implement only a small and coherent aspect of
        the overall transformation. This approach also makes it easy to examine the intermediate
        output during development, and to develop each step of the pipeline without distraction by
        what precedes or follows. But disk I/O is much slower than in-memory access, and the cost of
        writing the intermediate files is likely to compromise severely the efficiency of the
        transformation. Whether that matters it likely to depend on the volume of data; augmenting
        the execution time by an order of magnitude may not matter to the developer if the overall
        time is still subjectively brief.</para>
      <para>The overhead of disk I/O can be avoided by using pipelining utilities, whether broader
        purpose (such as Apache Cocoon [<xref linkend="cocoon"/>]) or more narrowly XML specific
        (XProc [<xref linkend="XProc"/>]). Pipelining tools avoid the overhead of disk I/O, although
        whether they build complete intermediate in-memory structures or decompose (and perhaps
        parallelize or stream) the transformation in a functional manner is implementation-specific.
        These technologies are well know to the Balisage audience: XProc has been the subject of six
        presentations by six different authors or teams of authors at Balisage alone (see
          <link>https://www.balisage.net/Proceedings/topics/XProc.html</link>), and Cocoon has also
        made several appearances, including as part of the toolkit used to produce the Balisage
        proceedings you are reading now
          (<link>https://www.balisage.net/Proceedings/vol17/acknowledgements.html</link>).
        Pipelining between or across XSLT stylesheets with technologies like Cocoon or XProc does
        not prohibit writing intermediate output to disk for examination during debugging, but it
        does not require it, and XProc in particular incorporates additional features that may be
        useful in complex transformations of XML documents (see
          <link>https://www.w3.org/TR/xproc/#pipeline-concepts</link>). The focus of the current
        report is on micropipelining, that is, on pipelines implemented within a single XSLT
        stylesheet, and we will not explore XProc or other technologies for pipelining between or
        across stylesheets, except to note that whether to implement a pipeline within a single
        stylesheet or between or across stylesheets is a separate consideration that lies outside
        the within-stylesheet scope of the present report.</para>
    </section>
    <section>
      <title>3. Micropipelining: pipelining within a single XSLT stylesheet</title>
      <para>As mentioned above, we use the term micropipelining to refer to pipelining within a
        single XSLT stylesheet. Micropipelines implemented within a single stylesheet can always be
        refactored and spread across multiple stylesheets, but in situations where the steps are
        conceptually part of what a human would consider a single operation, and where intermediate
        stages are unlikely to be of interest except for debugging purposes during development,
        combining them within a single XSLT stylesheet that performs that single operation may make
        for easier implementation and maintenance.</para>
      <para>The application that motivated this exploration is connected to our use of XML
        technologies to identify and analyze meter and rhyme in Russian verse. We presented a report
        on the identification of meter at Balisage 2015 (<xref linkend="birnbaum_2015"/>), and in
        order also to identify rhyme we need to convert normal Russian orthography to a phonetic
        representation. As long as the place of stress is known,<footnote>
          <para>The place of stress in Russian, as in English, is not normally indicated
            orthographically, and because stress can fall on different syllables in different words,
            including different inflected forms of the same lexeme, it is not predictable without
            linguistic (lexical and morphological) knowledge. The identification of meter depends on
            knowing the place of stress, and <xref linkend="birnbaum_2015"/> describes how stress is
            added automatically to enrich original unstressed input in natural Russian orthography
            before performing metrical analysis.</para>
        </footnote> the phonetic conversion, although complex, turns out to be easier in Russian
        than in English because Russian orthography, although not phonetic, is closer to the
        phonetics of the language than is the case with English. <footnote>
          <para>An early version of the algorithm we developed for this purpose was described in
              <xref linkend="adams_1997"/>; the XSLT implementation of the enhanced version
            currently used in the project is available at
              <link>https://github.com/djbpitt/poetry/blob/master/rhyme.xsl</link>.</para>
        </footnote></para>
      <para>It is common in historical linguistics to represent language change in terms of the
        application of ordered rules as a pipeline that accepts an initial form as input, pipes it
        (that is, passes it along) through a sequence of individual sound-change rules, and
        generates transformed output. Constraints on the order in which rules apply are
        traditionally described using alimentary and sanguinary metaphors, and those metaphors
        emerge from the linguistic reality that sound change may happen at a certain point in
        history and then cease to operate, that is, cease to be a productive process:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Feeding order.</emphasis> The output of one rule creates new
            input for another rule. For example, if in Rule A <emphasis role="ital">x → y</emphasis>
            (read as <emphasis role="ital">x</emphasis> is transformed into <emphasis role="ital"
              >y</emphasis>) and in Rule B <emphasis role="ital">y → z</emphasis>, Rule A feeds Rule
            B by creating new input for it.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Bleeding order.</emphasis> The output of one rule modifies a
            form that would otherwise have served as input for another rule. For example, if in Rule
            A <emphasis role="ital">z → q</emphasis> and in Rule B <emphasis role="ital">x → y / _
              z</emphasis> (read as <emphasis role="ital">x</emphasis> is transformed into <emphasis
              role="ital">y</emphasis> when it precedes <emphasis role="ital">z</emphasis>), Rule A
            is said to bleed Rule B because it reduces the application of Rule B by the destroying
            the environment it requires.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Counter-feeding order.</emphasis> The output of one rule does
            not create new input for another rule, but were the order of the two rules reversed,
            they would observe a feeding relationship. For example, if in Rule A <emphasis
              role="ital">y → z</emphasis> and in Rule B <emphasis role="ital">x → y</emphasis>, the
            two stand in a counter-feeding relationship, since Rule B creates what would have been
            new input into Rule A, but fails to do so because Rule A operates first, and is no
            longer active when the potential new input is created by Rule B.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Counter-bleeding order.</emphasis> The output of one rule does
            not bleed forms that might otherwise have served as input for another rule, but were the
            order of the two rules reversed, they would observe a bleeding relationship. For
            example, if in Rule A <emphasis role="ital">x → y / _ z</emphasis> and in Rule B
              <emphasis role="ital">z → q</emphasis>, the rules observe a counter-bleeding order
            because were the order reversed, Rule B would reduce the applicability of Rule A by
            destroying the context it requires.</para>
        </listitem>
      </itemizedlist>
      <para>Note that feeding and bleeding are not opposites, and that some rules may not be
        critically ordered with respect to others because their inputs, outputs, and conditioning
        environments do not intersect with one another. These types of relationships among rules are
        important because of their role in directing or constraining linguistic change (see, for
        example, <xref linkend="kiparsky_1973"/>). In the context of the present report, these
        relationships also provide a vocabulary for discussing the interaction of XPath functions
        and XSLT templates when those are used to implement transformations that model linguistic
        processes. Feeding, bleeding, and their opposites are appropriate for modeling historical
        language change because history imposes a real chronological order, but a similar model that
        uses similar terminology may also describe other linguistic phenomena, including the
        synchronic derivation of surface forms from more abstract underlying forms. In the present
        instance, we employ this framework to describe, as a pipeline of individual rules, the XSLT
        implementation of a transformation of standard Russian orthography (which is not phonetic)
        to a phonetic representation that can serve as the basis for identifying rhyme in
        verse.</para>
    </section>
  </section>
  <section>
    <title>Micropipelining: a closer look</title>
    <section>
      <title>Background and context</title>
      <para>When we began implementing in XSLT the machine-assisted identification and analysis of
        Russian rhyme, we were aware that pipelining was required because our algorithm for
        converting natural Russian orthography (enhanced by information about stress, which is not
        part of natural Russian orthography) was conceptualized as a series of rules of insertion,
        deletion, and replacement, the order of which was constrained by feeding and bleeding
        relationships. As we have been crafting bespoke solutions to these types of pipelining tasks
        over the years, we have wished for a tutorial that would describe the options, say something
        useful about the advantages and disadvantages of each, point out where they behave similarly
        or differently from one another, and perhaps make recommendations for deciding among them in
        the field. The principal goal of the present report is to fill the gap by describing and
        exploring the alternatives that we considered, including the one we eventually adopted for
        the Russian rhyme task.</para>
    </section>
    <section>
      <title>Convenience variables</title>
      <para>As the name implies, <emphasis role="bold">convenience variables</emphasis> are
        variables created for the benefit of the programmer, rather than because they necessarily
        improve the efficiency or operation of the program. The purpose of convenience variables is
        that typically they improve the legibility of the code, which makes it easier to develop
        (one piece at a time) and maintain.</para>
      <para>Variables that improve the efficiency of the transformation process itself are not (or:
        are not entirely) convenience variables (although they may also be convenient). For example,
        if we need to calculate the same result more than once in an XSLT stylesheet, performing the
        calculation only once and saving it in a variable that we can then reuse may reduce the
        amount of computation and improve the performance of the transformation. On the other hand,
        when we calculate a value that we will use only once, save it in a variable, and then use
        the variable, not only is there no similar saving, but we actually risk reducing the
        efficiency of the transformation by imposing the overhead needed to create the variable as
        an intermediate structure. Within XSLT, this is especially the case when variables are
        declared without explicit typing using the <code>@as</code> attribute, the omission of which
        results in the expensive creation of a temporary in-memory document (that we may not need)
        to hold the value.<footnote>
          <para><quote>If a sequence constructor is used with no <code>as</code> attribute, a
              temporary document is constructed. This is done by creating a new document node and
              using the value of the result sequence to form the children of the document
              node.</quote> (<xref linkend="kay_2008"/>, p. 503). There are times when constructing
            a temporary tree is nonetheless appropriate; for an example, see <xref
              linkend="kay_2008"/>, p. 510ff.</para>
        </footnote></para>
      <para>As an example of a convenience variable, consider an XSLT transformation to SVG where we
        need to calculate the <code>x</code> and <code>y</code> coordinates of an object and then
        plot it. If those calculations are complex, packing them into the declaration of the object
        may compromise its transparency. Compare the version with convenience variables:</para>
      <programlisting>&lt;xsl:variable name="xPos" as="xs:double" select="position() * $xScale"/&gt;
&lt;xsl:variable name="yPos" as="xs:double" select=". * $yScale"/&gt;
&lt;rect x={$xPos} y="-{$yPos}" width="{$width}" height="{$yPos}"/></programlisting>
      <para>to one without:</para>
      <programlisting>&lt;rect x={position() * $xScale} y="-{. * $yScale}" width="{$width}" height="{. * $yScale}"/></programlisting>
      <para>The more complex the calculation, the more the legibility may be improved through the
        use of convenience variables.<footnote>
          <para>In this case, the reuse of the same value in the <code>@y</code> and
              <code>@height</code> attributes means that the variable is not merely a matter of
            convenience, since that reuse also means that the same expression does not have to be
            evaluated more than once.</para>
        </footnote></para>
      <para>Convenience variables may play a role in pipelining when the result of one function is
        passed to another. For example,</para>
      <programlisting>&lt;xsl:value-of select="func2(func1($x))"/&gt;</programlisting>
      <para>may be rewritten as:</para>
      <programlisting>&lt;xsl:variable name="y" select="func1($x)"/&gt;
&lt;xsl:value-of select="func2($y)"&gt;</programlisting>
      <para>The difference between nesting explicit function syntax and nesting a variable
        containing the result of evaluating one function inside another function is discussed in
        greater detail below. The distinction between convenience variables and those that
        contribute to the quality of the code in ways that are not limited to human legibility is
        important because the costs and benefits of creating variables to hold intermediate values
        must take into consideration whether using the variable conveys advantages beyond
        convenience, that is, beyond the legibility that supports ease of maintenance.</para>
    </section>
    <section>
      <title>Nested functions</title>
      <para>One of the most natural types of micropipelining involves the nesting of functions, as
        in the example earlier that combines <code>normalize-space()</code> and
          <code>upper-case()</code> by nesting one inside the other. This simple nested structure
        involves only two functions, each of which accepts only one parameter, but as the number of
        functions and the number of parameters grows, it is easy to lose one’s place in a thicket of
        parentheses. Furthermore, the <code>normalize-space()</code> and <code>upper-case()</code>
        functions do not participate in feeding or bleeding relationships, which means that once we
        have determined that we need to use them, there is no risk of nesting them in a way that
        produces the wrong output, and that requires reordering. That matters because part of the
        challenge of multiple nested functions, and of the multiple pairs of parentheses that come
        with them, involves legibility during development, and the fact that the nesting order
        doesn’t matter obviates a potention need to transplant a contained function into a
        containing position, and vice versa, because we inadvertently nested them incorrectly the
        first time.</para>
      <para>Consider, for example, a situation using the Wordhoard TEI edition of <emphasis
          role="ital">Hamlet</emphasis>,<footnote>
          <para><link>http://www.wwp.northeastern.edu/outreach/seminars/xslt_2012-03/demos/xslt_intro/ham.xml</link></para>
        </footnote> where our task is to construct a comma-separated list of distinct speakers (from
        the <code>&lt;speaker&gt;</code> element children of the <code>&lt;sp&gt;</code> speech
        elements) in Act 4. We can retrieve a deduplicated list of all &lt;speaker&gt; values with a
        single XPath function wrapped around a single path expressions:
          <code>distinct-values(//body/div[4]//speaker)</code>. The catch is that this list includes
        not only <quote>Rosencrantz</quote> and <quote>Guildenstern</quote>, both of whom speak
        alone, but also <quote>Rosencrantz and Guildenstern</quote> (as the string content of a
        single <code>&lt;speaker&gt;</code> element) where they speak in unison, and our result must
        recognize that <quote>Rosencrantz and Guildenstern</quote> is not a unique speaker. It is
        possible to perform the operation in a single line using nested functions:</para>
      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="2.0"
    xpath-default-namespace="http://www.tei-c.org/ns/1.0"&gt;
    &lt;xsl:output method="text"/&gt;
    &lt;xsl:template match="/"&gt;
        &lt;xsl:value-of
            select="distinct-values(tokenize(string-join(//body/div[4]//speaker/replace(., ' and ', ' '), ' '), '\s+'))"
        /&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
      <para>Here we pipe the output of the innermost <code>replace()</code> function into
          <code>string-join()</code>, and then into <code>tokenize()</code>, and then into
          <code>distinct-values()</code>.<footnote>
          <para>Replacing <quote> and </quote> with a space is a brittle strategy, since it would
            break on multiple-speaker values that were joined in different ways, such as
              <code>&lt;speaker&gt;Curly, Larry, and Moe&lt;/speaker&gt;</code>. The point of the
            example is not find an optimal solution to the multiple-speaker problem, but to provide
            an example of pipelining functions.</para>
        </footnote> The order of functions has some flexibility, but the following constraints
        apply:</para>
      <orderedlist>
        <listitem>
          <para><code>string-join()</code> feeds <code>tokenize()</code></para>
        </listitem>
        <listitem>
          <para><code>tokenize()</code> feeds <code>distinct-values()</code></para>
        </listitem>
        <listitem>
          <para><code>replace()</code> may occur at any time before <code>tokenize()</code> (that
            is, before or after <code>string-join()</code>), or we can eliminate
              <code>replace()</code> entirely and instead use a predicate to exclude the eventual
            token with the value <quote>and</quote>.</para>
        </listitem>
      </orderedlist>
      <para>In favor of this strategy, nesting is the most direct possible representation of the
        pipeline relationship, since the input parameters to each function are included between its
        parentheses and each function statement evaluates to its output. Against this strategy, the
        depth of the nesting and the fact that several of the functions require multiple parameters
        greatly compromise the legibility, and thus the development and subsequent maintenance, of
        the code. Writing this code is messy and error-prone, and, recalling that code is read much
        more often than it is written, nobody would regard it as easy to read. We might try to
        improve the legibility through indentation:</para>
      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="2.0"
    xpath-default-namespace="http://www.tei-c.org/ns/1.0"&gt;
    &lt;xsl:output method="text"/&gt;
    &lt;xsl:template match="/"&gt;
        &lt;xsl:value-of
            select="distinct-values(
                tokenize(
                    string-join(
                        //body/div[4]//speaker/replace(
                            .,
                            ' and ',
                            ' '
                        ),
                        ' '),
                    '\s+')
                )"
        /&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
      <para>although most developers would not consider this very legible either.<footnote>
          <para>Furthermore, it does not emerge unchanged when the stylesheet is pretty-printed in
            &lt;oXygen/&gt;, and probably in at least some other editors.</para>
        </footnote> There is good reason that the functional programming language Lisp, known for
        its deeply nested parenthesized constructions, has been glossed humorously as <quote>Lots of
          Irritating Silly Parentheses</quote> and in other equivalent ways.<footnote>
          <para>see <link>https://xkcd.com/297/</link>. The name is actually derived from
              <quote>LISt Processor</quote>.</para>
        </footnote></para>
      <para>We can improve the legibility by rewriting the code to use convenience variables:</para>
      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="2.0"
    xpath-default-namespace="http://www.tei-c.org/ns/1.0"&gt;
    &lt;xsl:output method="text"/&gt;
    &lt;xsl:template match="/"&gt;
        &lt;xsl:variable name="first" as="xs:string+"
            select="//body/div[4]//speaker/replace(., ' and ', ' ')"/&gt;
        &lt;xsl:variable name="second" as="xs:string" select="string-join($first, ' ')"/&gt;
        &lt;xsl:variable name="third" select="tokenize($second, '\s+')"/&gt;        
        &lt;xsl:variable name="fourth" as="xs:string+" select="distinct-values($third)"/&gt;
        &lt;xsl:sequence select="$fourth"/&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
      <para>This improvement comes at a price though. Much as the complexity of the compound
        operations makes it easy for a developer inadvertently to nest the functions incorrectly in
        the nested syntax, it is also easy to order them incorrectly in the version that employs
        convenience variables. A debugging fix that is simple to describe (<quote>revise the order
          in which the functions are applied</quote>, which might incorrectly suggest that this
        could be mapped onto <quote>rearrange the lines in which the variables are created</quote>)
        turns out to be error prone because each line refers to two variable names, the one it is
        creating with its <code>@name</code> attribute and the one that it is using to determine the
        value, which is part of the content of its <code>@select</code> attribute. Changes in the
        order in which the functions are executed thus becomes far more complex and error-prone than
        dragging the lines into a different order. One way to conceptualize the challenge is that
        the variable declarations exist in a feeding relationship not just by virtue of their order
        (although XSLT prohibits counterfeeding variable declarations), but also by virtue of the
        way each declaration uses a value created by a different declaration.</para>
      <para>Given that variables in XSLT cannot be redeclared, one might wonder why XSLT requires
        that sibling variable declarations within a stylesheet be declared in the order in which
        they are referenced. That is, one might wonder why XSLT prohibits ordering sibling
          <code>&lt;xsl:variable&gt;</code> elements in counter-feeding order, much as it is
        possible to apply templates within one template that references another regardless of the
        order of the two. Whatever the reason for this restriction, it means that rearranging the
        order in which the functions are applied involves not only changing the references among
        them, but also modifying the order of the <code>&lt;xsl:variable&gt;</code> elements so that
        the order of declaration follows the order in which the values are used.</para>
      <para>One reason that deeply nested functions with multiple parameters are difficult to read
        is that code is written from left to right, which tacitly encourages humans to read it from
        left to right, but the feeding order (and thus the execution) of nested functions flows from
        the inside out. This means that the function names flow from right to left, but because
        functions may have multiple parameters, it is necessary to look to both the left and the
        right when moving out to the next level. In languages that support object-oriented
        programming, the <emphasis role="bold">dotted method notation</emphasis> avoids this clash
        because both the notation and the execution flow from left to right. For example, the
        following Python example returns the same results as the XSLT above:<footnote>
          <para>To keep the focus on the pipelining code, the speaker names, as they appear in the
            act, are supplied as a Python list. In a real application they would be extracted from
            the XML using one of the several Python XML libraries.</para>
        </footnote></para>
      <programlisting>names = ['King','Gertrude','King','Gertrude','King','Gertrude','King','Hamlet','Rosencrantz and Guildenstern',\
         'Hamlet','Rosencrantz','Hamlet','Rosencrantz','Hamlet','Rosencrantz','Hamlet','Rosencrantz','Hamlet',\
         'Rosencrantz','Hamlet','Rosencrantz','Hamlet','Guildenstern','Hamlet','King','Rosencrantz','King',\
         'Rosencrantz','King','Rosencrantz','King','Hamlet','King','Hamlet','King','Hamlet','King','Hamlet','King',\
         'Hamlet','King','Hamlet','King','Hamlet','King','Hamlet','King','Hamlet','King','Hamlet','King','Fortinbras',\
         'Captain','Fortinbras','Hamlet','Captain','Hamlet','Captain','Hamlet','Captain','Hamlet','Captain','Hamlet',\
         'Captain','Hamlet','Captain','Rosencrantz','Hamlet','Gertrude','Gentleman','Gertrude','Gentleman','Horatio',\
         'Gertrude','Ophelia','Gertrude','Ophelia','Gertrude','Ophelia','Gertrude','Ophelia','Gertrude','Ophelia',\
         'King','Ophelia','King','Ophelia','King','Ophelia','King','Ophelia','King','Gertrude','King','Gentleman',\
         'Gertrude','King','Laertes','Danes','Laertes','Danes','Laertes','Gertrude','Laertes','King','Laertes','King',\
         'Gertrude','King','Laertes','King','Laertes','King','Laertes','King','Laertes','King','Danes','Laertes',\
         'Ophelia','Laertes','Ophelia','Laertes','Ophelia','Laertes','Ophelia','Laertes','Ophelia','Laertes','King',\
         'Laertes','King','Horatio','Servant','Horatio','Sailor','Horatio','Sailor','Horatio','King','Laertes','King',\
         'Laertes','King','Messenger','King','Messenger','King','Laertes','King','Laertes','King','Laertes','King',\
         'Laertes','King','Laertes','King','Laertes','King','Laertes','King','Laertes','King','Laertes','King',\
         'Laertes','King','Laertes','King','Laertes','King','Gertrude','Laertes','Gertrude','Laertes','Gertrude',\
         'Laertes','King']
result = set(' '.join(names).replace(' and ', ' ').split())
print(result)</programlisting>
      <para>The <code>set()</code> function is used to remove the duplicates and its input is
        contained in the parentheses that immediately follow the function name, but otherwise the
        order of execution and the syntactic expression both flow from left to right using dotted
        method notation: from <code>join()</code> (equivalent to XSLT <code>string-join()</code>)
        into <code>replace()</code> (also called <code>replace()</code> in XSLT) into
          <code>split()</code> (equivalent to <code>tokenize()</code> in XSLT).<footnote>
          <para>The syntax of the <code>join()</code> method <quote>appears to make some programmers
              feel uncomfortable</quote>. As is explained in <xref linkend="python-join"/>,
              <code>join()</code> is a method not of the list (the Python equivalent of an XSLT
            sequence, in this case the sequence of speaker names), but of the string separator (in
            this example, a space character), which might suggest that the code is operating on the
            separator character and using the list to perform the operation. The reason this may
            feel unnatural is that what is being joined is the list items, and a human might think
            that we perform joining to modify a list, and not to modify a separator string. That
            perception is buttressed by the Python <code>split()</code> function, where
              <code>'Curly,Larry,Moe'.split(',')</code> splits the Three Stooges at the comma. That
            is, <code>split()</code> is a method of the complex object we seek to modify with the
            help of a simple string, but <code>join()</code> is a method of the simple string that
            we use (at least from a human perspective) to modify a complex list. The perceived
            assymetry of <code>join()</code> with <code>split()</code> invites confusion, especially
            for an XSLT programmer for whom <quote>first</quote> or <quote>leftmost</quote> feels
            like the locus of an operation because that’s the way the signatures of the XPath
              <code>contains()</code>, <code>ends-with()</code>, <code>tokenize()</code>, and
            (especially) <code>string-join()</code> functions operate.</para>
        </footnote></para>
      <para>While dotted method notation is natural within an object-oriented model, the notation is
        also not inherently incompatible with functional programming paradigms. Pipelines with dot
        notation when working within a function model in Python are supported by the PyFunctional
        package, which <quote>makes creating data pipelines easy by using chained functional
          operators</quote>, e.g.:
        <programlisting>seq(1, 2, 3).map(lambda x: x * 2).reduce(lambda x, y: x + y)</programlisting>
          (<xref linkend="pyfunctional"/>) XSLT, however, does not support a left-to-right function
        chaining notation, which means that if a pipeline of XSLT functions is to be expressed in a
        single line of code, it must be expressed through nesting, and must therefore operate from
        the inside out even though human coders might more instinctively read and write from the
        left to the right.</para>
    </section>
    <section>
      <title>Variables, templates, and functions</title>
      <para>The description of nested functions above was based on functions from the core XPath
        library, but much more complex operations can be embedded in user-defined functions, which
        can then be nested on a single line, similarly to the nesting in the basic XPath library
        example. Indeed, a user-defined function can transform an entire input document into an
        entire intermediate document, optionally assigning the value of the function to a variable,
        and then apply another function to the intermediate document. If we create two (imaginary)
        user-defined functions, one that translates a document from Russian into English and another
        that tokenize the English translation and returns a report (perhaps an HTML table) of the
        distribution of Scrabble values of the words, the starting point of the transformation might
        look like:</para>
      <programlisting>&lt;xsl:template match="/"&gt;
    &lt;xsl:variable name="intermediate" as="document-node()" select="djb:translate_into_english(.)"/&gt;
    &lt;xsl:sequence select="djb:create_scrabble_values($intermediate)"/&gt;
&lt;/xsl:template&gt;</programlisting>
      <para>As was the case in the discussion of core XPath library functions above,
          <code>$intermediate</code> is a convenience variable, and the functions can,
        alternatively, be nested directly:</para>
      <programlisting>&lt;xsl:template match="/"&gt;
    &lt;xsl:sequence select="djb:create_scrabble_values(djb:translate_into_english(.))"/&gt;
&lt;/xsl:template&gt;</programlisting>
      <para>The two user-defined functions might call other functions, apply templates, or otherwise
        perform operations of arbitrary complexity.</para>
      <para>Insofar as functions and templates have similar properties (and are compiled to the same
        type of operations within the processor), instead of creating user-defined functions, it is
        possible to use convenience variables with templates:</para>
      <programlisting>&lt;xsl:template match="/"&gt;
    &lt;xsl:variable name="intermediate" as="document-node()"&gt;
        &lt;xsl:apply-templates select="." mode="translate_into_english"/&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:apply-templates select="$intermediate" mode="create_scrabble_values"/&gt;
&lt;/xsl:template&gt;</programlisting>
      <para>Dimitre Novatchev provided real examples of this type of chaining in XSLT 1.0 and 2.0 in
        a StackOverflow response in 2010. (<xref linkend="novatchev_2010"/>)</para>
      <para>The use of intermediate variables with either functions or templates neither requires
        nor precludes serializing all or part of the intermediate results with
          <code>&lt;xsl:result-document&gt;</code> or <code>&lt;xsl:message&gt;</code> if that is
        needed for development or for production. But the use of templates with intermediate
        variables for pipelining does exhibit one of the principal limitations discussed above of
        using functions with variables for pipelining: editing the pipeline requires, beyond the
        insertion, deletion, or rearrangement of lines, changing the value of the
          <code>@select</code> attribute when the intermediate variable is used. For example, in the
        code above, if between the translation into English and the creation of the Scabble value
        output we want to pluralize all words that are capable of being pluralized, not only do we
        need to create another variable, but we also need to change the value of the
          <code>@select</code> attribute of an <code>&lt;xsl:apply-templates&gt;</code> elements in
        a different line (modifications associated with the insertion are highlighted):</para>
      <programlisting>&lt;xsl:template match="/"&gt;
    &lt;xsl:variable name="intermediate" as="document-node()"&gt;
        &lt;xsl:apply-templates select="." mode="translate_into_english"/&gt;
    &lt;/xsl:variable&gt;
    <emphasis role="bital">&lt;xsl:variable name="pluralized" as="document-node()"&gt;
        &lt;xsl:apply-templates select="$intermediate" mode="pluralize"/&gt;
    &lt;/xsl:variable&gt;</emphasis>
    &lt;xsl:apply-templates select="<emphasis role="bital">$pluralized</emphasis>" mode="create_scrabble_values"/&gt;
&lt;/xsl:template&gt;</programlisting>
      <para>Inserting or deleting a step requires, in addition to the insertion or deletion itself,
        one adjustment to the value of a <code>@select</code> attribute in a different line.
        Rearranging steps requires more adjustments. There is also no easy way of changing the
        location where intermediate results are serialized, whether for development or for
        production. And because the use of intermediate variables requires additional physical lines
        of code for legibility, it becomes harder to see the entire pipeline as an interrupted
        sequence. What would be more robust, flexible, and maintainable would be a pattern that has
        the following properties:</para>
      <itemizedlist>
        <listitem>
          <para>Each step of the pipeline fits on a single short line of XSLT code, with no
            wrappers, no intervening statements, and nothing else that intrudes into a bare-bones
            list of steps.</para>
        </listitem>
        <listitem>
          <para>Each step of the pipeline is entirely self-contained. Inserting, deleting, or
            rearranging steps does not require any modification to any code pertaining to other
            steps.</para>
        </listitem>
        <listitem>
          <para>The list of steps does not mention or pass any parameters explicitly. Parameter
            passing is handled within the processing steps (whether functions or templates), and
            changing the sequence of steps does not require changing the code that manages
            parameters within any of the steps.</para>
        </listitem>
        <listitem>
          <para>Intermediate results can be dumped at any time (or at more than one time) as a step
            in the pipeline, whether for development or for production purposes. Dumping is a part
            of the pipeline that happens between transformative operations on the data; it is not
            part of any individual transformative operation within the pipeline.</para>
        </listitem>
        <listitem>
          <para>Optional: Steps can be added to the list before the code that performs them has been
            created, without requiring any adjustment to the parameters.<footnote>
              <para>This can be done with functions or templates by creating stubs that pass their
                input along to the next step in the pipeline, but it would be more convenient to
                have that happen by default, without separate explicit stub code for each
                not-yet-fully-specified step.</para>
            </footnote></para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>The visitor pattern</title>
      <section>
        <title>The visitor pattern in an XSLT context</title>
        <para>The <emphasis role="bold">visitor pattern</emphasis> is usually defined and
          illustrated in an object-oriented context that may be difficult to map onto the XSLT
          programming paradigm.<footnote>
            <para>I am grateful to Wendell Piez for introducing me to this pattern, and for his many
              generous contributions, in the course of a rich correspondence in spring 2017, to my
              elaboration of the ideas described here. Piez identifies this strategy as an instance
              of the visitor pattern in <xref linkend="piez_2014"/>.</para>
          </footnote> James Sugrue provides some real-world analogies:</para>
        <blockquote>
          <para>A real world analogy always helps with the understanding of a design pattern. One
            example I have seen for the Visitor pattern in action is a taxi example, where the
            customer calls orders a taxi, which arrives at his door. Once the person sits in, the
            visiting taxi is in control of the transport for that person.</para>
          <para>Shopping in the supermarket is another common example, where the shopping cart is
            your set of elements. When you get to the checkout, the cashier acts as a visitor,
            taking the disparate set of elements (your shopping), some with prices and others that
            need to be weighed, in order to provide you with a total.</para>
          <para>…</para>
          <para>In summary, if you want to decouple some logical code from the elements that you’re
            using as input, visitor is probably the best pattern for the job. (<xref
              linkend="sugrue_2010"/>)</para>
        </blockquote>
        <para>Because XSLT is not object-oriented, logical operations on objects (e.g., nodes of
          various types, atomic values) are naturally decoupled from the objects themselves. Michael
          Kay, writing about the simulation of higher-order functions in XSLT 2.0, situates the
          visitor pattern in a functional context:</para>
        <blockquote>
          <para>[Y]ou might write a function that does a depth-first traversal of a tree and
            processes each node in the tree using a function that is supplied as an argument. This
            makes it possible to use one tree-walking routine to achieve many different effects (you
            might recognize this as the <emphasis role="ital">Visitor Pattern</emphasis>).</para>
          <para>In XSLT (and XPath), functions are not first-class objects, so they cannot be passed
            as arguments to other functions.<footnote>
              <para>[Added:] This statement is based on XPath 2.0 and XSLT 2.0. Functions may be
                used as first-class objects in more recent versions of the standards.</para>
            </footnote> However, the template-matching capability of
              <code>&lt;xsl:apply-templates&gt;</code> can be used to simulate higher order
            functions.</para>
          <para>The use of <code>&lt;xsl:apply-templates&gt;</code> has been developed to a fine art
            by Dimitre Notatchev in his FXSL library (<link>http://fxsl.sourceforge.net/</link>),
            which provides many examples of the technique. (<xref linkend="kay_2008"/>)</para>
        </blockquote>
      </section>
      <section>
        <title>The source</title>
        <para>The full XSLT stylesheet used to identify rhyme in Russian verse, which is the source
          of the excerpts presented here, is available at
            <link>https://raw.githubusercontent.com/djbpitt/poetry/master/rhyme.xsl</link>. It can
          be run against itself, in which case it processes default input that is embedded in the
          stylesheet. Additional documentation, and the ancillary XSLT stylesheets that it imports,
          are available at the project’s GitHub repo at
            <link>https://github.com/djbpitt/poetry</link>.</para>
      </section>
      <section>
        <title>Defining the order of operations</title>
        <para>The transformation is driven by a sequence of operations, each of which is represented
          by an empty element in a custom namespace:</para>
        <programlisting>&lt;xsl:variable name="operations" as="element()+"&gt;
    &lt;djb:prepareWords/&gt;
    &lt;djb:lexical/&gt;
    &lt;djb:proclitics/&gt;
    &lt;djb:enclitics/&gt;
    &lt;djb:tsa/&gt;
    &lt;djb:palatalize/&gt;
    &lt;djb:jot/&gt;
    &lt;djb:romanize/&gt;
    &lt;djb:finalDevoice/&gt;
    &lt;djb:regressiveDevoice/&gt;
    &lt;djb:regressiveVoice/&gt;
    &lt;djb:palatalAssimilation/&gt;
    &lt;djb:consonantCleanup/&gt;
    &lt;djb:vowelReduction/&gt;
    &lt;!-- 
        diagnosticOutput writes the string to stderr as an &lt;xsl:message&gt;
        move it around or comment it out, as appropriate
    --&gt;
    &lt;!--&lt;djb:diagnosticOutput/&gt;--&gt;
    &lt;djb:stripSpaces/&gt;
    &lt;djb:rhymeString/&gt;
&lt;/xsl:variable&gt;</programlisting>
        <para>Note that <code>&lt;djb:diagnosticOutput&gt;</code> can be inserted wherever the
          developer wishes to examine interim results, including in multiple locations.</para>
      </section>
      <section>
        <title>Starting the transformation</title>
        <para>The transformation is run once for each <code>&lt;line&gt;</code> element in a poem.
          It operates through sibling recursion, applying templates to the first member of the
            <code>$operations</code> variable defined in the example above and passing as parameters
          the current line (<code>$input</code>) and the sequence of remaining parameters
            (<code>remove($operations, 1)</code>):</para>
        <programlisting>&lt;xsl:apply-templates select="$operations[1]" mode="operate"&gt;
    &lt;xsl:with-param name="input" select="."/&gt;
    &lt;xsl:with-param name="remaining" select="remove($operations, 1)"/&gt;
&lt;/xsl:apply-templates&gt;</programlisting>
        <para>Note that we apply templates not to the input (the <code>&lt;line&gt;</code> element),
          but to the operation, and we pass along to the operation as parameters the input and the
          sequence of remaining operations. None of the operations refers to any other explicitly,
          and none refers to any specific parameters, which means that inserting, deleting, and
          rearranging operations involves changing only the list of operations itself. Because the
          sibling recursion strategy will walk through the operations in order (see below), one
          operation feeds the next without having to know its identity.</para>
      </section>
      <section>
        <title>Template matching</title>
        <para>When we apply templates to an element in the sequence of operations, a single template
          matches all elements in the custom namespace, and it dispatches the processing to the
          appropriate location within an <code>&lt;xsl:choose</code> element. That single template
          begins as follows:</para>
        <programlisting>&lt;xsl:template match="djb:*" mode="operate"&gt;
    &lt;xsl:param name="input" as="xs:string" required="yes"/&gt;
    &lt;xsl:param name="remaining" as="element()*"/&gt;
    &lt;xsl:variable name="results" as="xs:string*"&gt;
        &lt;xsl:choose&gt;
            &lt;!-- ******************************************* --&gt;
            &lt;!-- djb:lexical: Idiosyncrasies in pronunciation (including -ogo) --&gt;
            &lt;!-- ******************************************* --&gt;
            &lt;xsl:when test="self::djb:lexical"&gt;
                &lt;xsl:sequence select="djb:lexical($input)"/&gt;
            &lt;/xsl:when&gt;
            &lt;!-- ******************************************* --&gt;
            &lt;!-- djb:proclitics: Merge proclitics with bases --&gt;
            &lt;!-- ******************************************* --&gt;
            &lt;xsl:when test="self::djb:proclitics"&gt;
                &lt;xsl:sequence select="djb:proclitic($input, 1)"/&gt;
            &lt;/xsl:when&gt;
            &lt;!-- ******************************************* --&gt;
            &lt;!-- djb:enclitics: Merge enclitics with bases --&gt;
            &lt;!-- ******************************************* --&gt;
            &lt;xsl:when test="self::djb:enclitics"&gt;
                &lt;xsl:sequence select="djb:enclitic($input, 1)"/&gt;
            &lt;/xsl:when&gt;
            &lt;!-- ******************************************* --&gt;
            &lt;!-- djb:tsa: Convert ть?ся$ to тса --&gt;
            &lt;!-- ******************************************* --&gt;
            &lt;xsl:when test="self::djb:tsa"&gt;
                &lt;xsl:sequence select="replace($input, 'ться$', 'тса')"/&gt;
            &lt;/xsl:when&gt;
            &lt;!-- ******************************************* --&gt;
            &lt;!-- djb:palatalize: Capitalize all palatalized consonants (including unpaired) --&gt;
            &lt;!-- ******************************************* --&gt;
            &lt;xsl:when test="self::djb:palatalize"&gt;
                &lt;xsl:variable name="result1" as="xs:string+"&gt;
                    &lt;xsl:analyze-string select="$input"
                        regex="([бвгдзклмнпрстфх])([яеиёюЯЕИЁЮь])"&gt;
                        &lt;xsl:matching-substring&gt;
                            &lt;xsl:sequence
                                select="concat(upper-case(regex-group(1)), regex-group(2))"/&gt;
                        &lt;/xsl:matching-substring&gt;
                        &lt;xsl:non-matching-substring&gt;
                            &lt;xsl:sequence select="."/&gt;
                        &lt;/xsl:non-matching-substring&gt;
                    &lt;/xsl:analyze-string&gt;
                &lt;/xsl:variable&gt;
                &lt;xsl:sequence select="translate(string-join($result1, ''), 'чйщ', 'ЧЙЩ')"/&gt;
            &lt;/xsl:when&gt;
        &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;
&lt;/xsl:template&gt;</programlisting>
        <para>The pipline operations are the only elements in the <code>djb:</code> namespace, so
          this template matches all of them, and nothing else. It accepts the two parameters and
          then creates a variable called <code>$results</code>, inside of which it uses
            <code>&lt;xsl:choose&gt;</code> to identify the operation that is being processed. Some
          of these operations (e.g., <code>&lt;djb:lexical&gt;</code>,
            <code>&lt;djb:proclitics&gt;</code>, <code>&lt;djb:enclitics&gt;</code>) call
          user-defined functions (in a separate function library) to do their work. Others use core
          XPath library functions (e.g., <code>&lt;djb:tsa&gt;</code>). Others are longer and
          perform more complex processing (e.g., <code>&lt;djb:palatalize&gt;</code>). Each
            <code>&lt;xsl:when&gt;</code> element, which processes a specific operation, returns a
          sequence as the value of the (interim) <code>$results</code> variable that wraps the
            <code>&lt;xsl:choose&gt;</code> element. How this variable contributes to the result of
          the surrounding template is described below.</para>
      </section>
      <section>
        <title>Unmatched operations</title>
        <para>At different moments in the development we implemented different treatment of
          operations that are not matched in the single processing template. One option is to let
          operations in the sequence but not associated with processing code pass their logical
          input, unchanged, along to the next step in the pipeline. This is the simplest form of a
          stub; the name of the operation is present, but the default behavior if the operation is
          not defined is to pass:</para>
        <programlisting>&lt;!-- ******************************************* --&gt;
&lt;!-- Default to continue processing if operate step has no code--&gt;
&lt;!-- ******************************************* --&gt;
&lt;xsl:otherwise&gt;
    &lt;xsl:apply-templates select="$remaining[1]" mode="visit"&gt;
        &lt;xsl:with-param name="input" select="$input"/&gt;
        &lt;xsl:with-param name="remaining" select="remove($remaining, 1)"/&gt;
    &lt;/xsl:apply-templates&gt;
&lt;/xsl:otherwise&gt;--&gt;</programlisting>
        <para>The <code>&lt;xsl:otherwise&gt;</code> default applies templates to the next operation
          in the sequence, passing along the input it received unchanged.</para>
        <para>Alternatively, when the development is complete, we might prefer to raise a fatal
          error if the sequence of operations includes any that have not been defined:</para>
        <programlisting>&lt;!-- ******************************************* --&gt;
&lt;!-- Default to terminate if operate step has no code--&gt;
&lt;!-- ******************************************* --&gt;
&lt;xsl:otherwise&gt;
    &lt;xsl:message terminate="yes"&gt;Unmatched visitor element &lt;xsl:value-of
        select="local-name()"/&gt;&lt;/xsl:message&gt;
&lt;/xsl:otherwise&gt;</programlisting>
        <para>One or the other of these two defaults should be commented out at all times.</para>
      </section>
      <section>
        <title>Processing the next operation</title>
        <para>Except for the <quote>pass</quote> default, each operation creates a sequence that
          becomes the value of the <code>$results</code> variable that wraps the
            <code>&lt;xsl:choose&gt;</code> element. In some cases the value is a single string; in
          others it is a sequence of strings (thus the plural name).<footnote>
            <para>The first operation (<code>&lt;djb:prepareWords&gt;</code>) returns a sequence of
              elements, rather than a string or sequence of strings, and is handled separately in a
              template that matches the operation fully qualified name explicitly, outside the
              template that matches <code>djb:*</code>. The more explicit <code>@match</code> value
              has a higher priority than the wildcard element match, and therefore supervenes when
              needed.</para>
          </footnote> After the <code>$results</code> variable has been constructed, it is used to
          construct a <code>$result</code> (singular), typed as a single string. The template then
          passes that value to the next operation, using sibling recursion:</para>
        <programlisting>&lt;xsl:variable name="result" as="xs:string" select="string-join($results, '')"/&gt;
&lt;xsl:apply-templates select="$remaining[1]" mode="#current"&gt;
    &lt;xsl:with-param name="input" select="$result"/&gt;
    &lt;xsl:with-param name="remaining" select="remove($remaining, 1)"/&gt;
&lt;/xsl:apply-templates&gt;</programlisting>
      </section>
      <section>
        <title>Termination</title>
        <para>The sibling recursion pattern removes each operation after it has been processed and
          then passes the sequence of remaining operations along as a parameter. When the last
          operation has been processed and removing it from the sequence of operations leaves an
          empty sequence, the pipeline has finished, and returns gracefully:</para>
        <programlisting>&lt;xsl:if test="empty($remaining)"&gt;
    &lt;xsl:sequence select="$result"/&gt;
&lt;/xsl:if&gt;</programlisting>
      </section>
      <section>
        <title>Evaluation</title>
        <para>The paradigm described here meets all of the desiderata enumerated earlier and
          repeated here:</para>
        <itemizedlist>
          <listitem>
            <para>Each step of the pipeline fits on a single short line of XSLT code, with no
              wrappers, no intervening statements, and nothing else that intrudes into a bare-bones
              list of steps.</para>
          </listitem>
          <listitem>
            <para>Each step of the pipeline is entirely self-contained. Inserting, deleting, or
              rearranging steps does not require any modification to any code pertaining to other
              steps.</para>
          </listitem>
          <listitem>
            <para>The list of steps does not mention or pass any parameters explicitly. Parameter
              passing is handled within the processing steps (whether functions or templates), and
              changing the sequence of steps does not require changing the code that manages
              parameters within any of the steps.</para>
          </listitem>
          <listitem>
            <para>Intermediate results can be dumped at any time (or at more than one time) as a
              step in the pipeline, whether for development or for production purposes. Dumping is a
              part of the pipeline that happens between transformative operations on the data; it is
              not part of any individual transformative operation within the pipeline.</para>
          </listitem>
          <listitem>
            <para>Steps can be added to the list before the code that performs them has been
              created, without requiring any adjustment to the parameters.</para>
          </listitem>
        </itemizedlist>
        <para/>
      </section>
    </section>
    <section>
      <title>nested calls to the replace() functions</title>
      <para>Developers who work with uncommon writing systems (ancient, medieval, minority, etc.)
        often need to convert documents from one character coding to another. Sometimes the writing
        system is the same but the character set is different, such as when pre-Unicode legacy
        documents must be converted to Unicode. Sometimes the conversion is from one writing system
        to another, such as when Cyrillic texts are Romanized for library catalog purposes, or when
        linguistic field data in domain-specific notation are converted to International Phonetic
        Alphabet (IPA). If the mapping from one character representation to another is one to one,
        it can be implemented with a single <code>translate()</code> function, which has the
        advantage of not suffering from feeding or bleeding conflicts (that is,
          <code>translate($input,'AB','BA')</code> replaces <emphasis role="ital">A</emphasis> with
          <emphasis role="ital">B</emphasis> and <emphasis role="ital">B</emphasis> with <emphasis
          role="ital">A</emphasis> simultaneously, without requiring an intermediate nonce variable.
        But mappings that are one to many, many to many, and many to one cannot be managed with
          <code>translate()</code>, and require multiple applications of <code>replace()</code> (in
        a way that is sensitive to feeding and bleeding issues). Mappings that are not one to one
        must be processed before those that are one to one because the components of a character
        sequence may also participate in one-to-one relationships outside that sequence. That is,
        those mappings exist in a mutual bleeding relationship, and correct processing is that the
        mapping that is not one to one takes precedence.</para>
      <para>Even if we bracket ordering constraints, the necessity of pipelining
          <code>replace()</code> functions (in our work, often more than two dozen) raises the
        legibility and maintainability issues discussed above. We avoid those issues by implementing
        a table-driven approach that separates the processing with <code>replace()</code> from the
        match and replacement values.<footnote>
          <para>The match parameter is a regular expression, but in most of our applications it has
            turned out to be a string, that is, a regular expression that uses no metacharacters or
            escapes and matches only its entire literal self.</para>
        </footnote> The example below is drawn from Uyghur-to-IPA mapping project</para>
    </section>
    <section>
      <title>The mapping table</title>
      <para>The mapping table consists of pairs of match and replacement strings, grouped as those
        that are not one to one (&lt;multiple&gt;) and those that are
        (<code>&lt;unitary&gt;</code>):</para>
      <programlisting>&lt;pairs&gt;
    &lt;multiple&gt;
        &lt;pair&gt;
            &lt;uyg&gt;ch&lt;/uyg&gt;
            &lt;ipa&gt;ʧʰ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;gh&lt;/uyg&gt;
            &lt;ipa&gt;ɣ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;ng&lt;/uyg&gt;
            &lt;ipa&gt;ŋ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;sh&lt;/uyg&gt;
            &lt;ipa&gt;ʃ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;zh&lt;/uyg&gt;
            &lt;ipa&gt;ʒ&lt;/ipa&gt;
        &lt;/pair&gt;
    &lt;/multiple&gt;
    &lt;unitary&gt;
        &lt;pair&gt;
            &lt;uyg&gt;a&lt;/uyg&gt;
            &lt;ipa&gt;a&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;e&lt;/uyg&gt;
            &lt;ipa&gt;ɛ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;b&lt;/uyg&gt;
            &lt;ipa&gt;b&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;d&lt;/uyg&gt;
            &lt;ipa&gt;d&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;é&lt;/uyg&gt;
            &lt;ipa&gt;e&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;f&lt;/uyg&gt;
            &lt;ipa&gt;f&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;g&lt;/uyg&gt;
            &lt;ipa&gt;g&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;h&lt;/uyg&gt;
            &lt;ipa&gt;h&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;x&lt;/uyg&gt;
            &lt;ipa&gt;χ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;i&lt;/uyg&gt;
            &lt;ipa&gt;i&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;j&lt;/uyg&gt;
            &lt;ipa&gt;ʤ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;k&lt;/uyg&gt;
            &lt;ipa&gt;k&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;q&lt;/uyg&gt;
            &lt;ipa&gt;q&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;l&lt;/uyg&gt;
            &lt;ipa&gt;l&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;l&lt;/uyg&gt;
            &lt;ipa&gt;ɫ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;m&lt;/uyg&gt;
            &lt;ipa&gt;m&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;n&lt;/uyg&gt;
            &lt;ipa&gt;n&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;o&lt;/uyg&gt;
            &lt;ipa&gt;o&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;ö&lt;/uyg&gt;
            &lt;ipa&gt;ø&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;p&lt;/uyg&gt;
            &lt;ipa&gt;pʰ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;r&lt;/uyg&gt;
            &lt;ipa&gt;r&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;s&lt;/uyg&gt;
            &lt;ipa&gt;s&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;t&lt;/uyg&gt;
            &lt;ipa&gt;tʰ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;u&lt;/uyg&gt;
            &lt;ipa&gt;u&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;ü&lt;/uyg&gt;
            &lt;ipa&gt;y&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;w&lt;/uyg&gt;
            &lt;ipa&gt;w&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;y&lt;/uyg&gt;
            &lt;ipa&gt;j&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;z&lt;/uyg&gt;
            &lt;ipa&gt;z&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;‘&lt;/uyg&gt;
            &lt;ipa&gt;ˀ&lt;/ipa&gt;
        &lt;/pair&gt;
        &lt;pair&gt;
            &lt;uyg&gt;'&lt;/uyg&gt;
            &lt;ipa&gt;ˀ&lt;/ipa&gt;
        &lt;/pair&gt;
    &lt;/unitary&gt;
&lt;/pairs&gt;</programlisting>
      <para>Note that some of the characters in the <code>&lt;multiple&gt;</code> portion of the
        mapping table also appear in the <code>&lt;unitary&gt;</code> portion.</para>
    </section>
    <section>
      <title>Processing mappings that are not one to one</title>
      <para>As explained above, mappings that are not one to one must be processed before those that
        are, and the processing requires the <code>replace()</code> function. This processing is
        performed with a single user-defined function:</para>
      <programlisting>&lt;xsl:function name="djb:multireplace" as="xs:string"&gt;
    &lt;!-- this function handles all replacements that aren't one-to-one --&gt;
    &lt;xsl:param name="instring" as="xs:string"/&gt;
    &lt;xsl:param name="pairing" as="xs:integer"/&gt;
    &lt;xsl:variable name="temp"
        select="replace($instring,$multiple[$pairing]/orthr,$multiple[$pairing]/ipa)"/&gt;
    &lt;xsl:choose&gt;
        &lt;xsl:when test="$pairing lt $multipairs"&gt;
            &lt;xsl:value-of select="djb:multireplace($temp,$pairing + 1)"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
            &lt;xsl:value-of select="$temp"/&gt;
        &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;</programlisting>
      <para>The replacements that are not one to one are initiated with:</para>
      <programlisting>&lt;xsl:variable name="multipairs" select="count($multiple)" as="xs:integer"/&gt;
&lt;xsl:variable name="temp"&gt;
    &lt;!-- normalize space, lowercase, do all non-one-to-one-replacements
  --&gt;
    &lt;xsl:value-of select="djb:multireplace(normalize-space(lower-case(.)),1)"/&gt;
&lt;/xsl:variable&gt;</programlisting>
      <para>The second argument (the integer <quote>1</quote>) get mapped to the
          <code>$pairing</code> variable inside the <code>djb:multireplace()</code> function. The
        function calls itself recursively, incrementing the second argument, and returning a value
        only when all pairs that are not one to one have been processed. The separation of the
          <code>replace()</code> function from the arguments on which it operates makes it easy for
        the developer to insert, delete, or rearrange pairings in the mapping file.</para>
    </section>
    <section>
      <title>Processing mappings that are one to one</title>
      <para>Mapping that are one to one can be processed with a single instance of the
          <code>translate()</code> function:</para>
      <programlisting>&lt;xsl:variable name="unitary-orthr" select="string-join($unitary//orthr,'')"/&gt;
&lt;xsl:variable name="unitary-ipa" select="string-join($unitary//ipa,'')"/&gt;
&lt;xsl:sequence select="translate($temp,$unitary-orthr,$unitary-ipa)"/&gt;</programlisting>
      <para>The table-driven design all but eliminates the opportunity for off-by-one errors when
        aligning the individual characters in the match argument with those in the replacement
        argument.</para>
    </section>
  </section>
  <section>
    <title>Conclusion</title>
    <para>The most natural and direct human understanding of pipelining is that it takes the output
      of one operation (function or template) and uses it as the input to the next. The most direct
      representations of that processing model in XSLT code encounter challenges to legibility as
      developers drown in a sea of parentheses or struggle to update variable names and references
      as they add, delete, or rearrange steps in the pipeline. The use cases illustrated in this
      report avoid those challenges and struggles by moving the statement of the pipeline into a
      sequence of simple steps (operations in the visitor pattern, mapping pairs in the
      transliteration example) that are easy to read and to edit because adjustments in a step are
      entirely self-contained, and do not require adjustments in others. The feeding and bleeding
      logic remains the intellectual responsibility of the developer, but the inevitable mistakes in
      this area are easily remedied during debugging because modifications in the order of pipeline
      steps are constrained to a single element. None of the methods described here is new, but
      their explicit juxtaposition, comparison, and evaluation in a tutorial context based on real
      use cases has clarified much about micropipelining for the author, and, it is hoped, for the
      reader, as well.</para>
  </section>
  <bibliography>
    <title>Works cited</title>
    <bibliomixed xml:id="cocoon" xreflabel="Cocoon">Apache Cocoon.
        <link>http://cocoon.apache.org/</link></bibliomixed>
    <bibliomixed xml:id="adams_1997" xreflabel="Adams and Birnbaum 1997">Adams, Lawrence D. and
      David J. Birnbaum. <emphasis role="ital">Text technology</emphasis> 7, 1 (1997): 1–17.
      Corrected reprint available at
        <link>http://poetry.obdurodon.org/reports/adams-birnbaum.xhtml</link></bibliomixed>
    <bibliomixed xml:id="birnbaum_2015" xreflabel="Birnbaum and Thorsen 2015">Birnbaum, David J.,
      and Elise Thorsen. <quote>Markup and meter: Using XML tools to teach a computer to think about
        versification.</quote> Presented at Balisage: The Markup Conference 2015, Washington, DC,
      August 11 - 14, 2015. In <emphasis role="ital">Proceedings of Balisage: The Markup Conference
        2015.</emphasis> Balisage Series on Markup Technologies, vol. 15 (2015). DOI:
      10.4242/BalisageVol15.Birnbaum01.
        <link>https://www.balisage.net/Proceedings/vol15/html/Birnbaum01/BalisageVol15-Birnbaum01.html</link></bibliomixed>
    <bibliomixed xml:id="fuller_2016" xreflabel="Fuller 2016">Fuller, James. <quote>A catalog of
        functional programming idioms in XQuery 3.1.</quote> Presented at <emphasis role="ital"
        >Balisage: The Markup Conference 2016, Washington, DC, August 2 - 5, 2016.</emphasis> In
      Proceedings of Balisage: The Markup Conference 2016. <emphasis role="ital">Balisage series on
        markup technologies,</emphasis> vol. 17 (2016). DOI: 10.4242/BalisageVol17.Fuller01.
        <link>https://www.balisage.net/Proceedings/vol17/html/Fuller01/BalisageVol17-Fuller01.html</link></bibliomixed>
    <bibliomixed xml:id="gamma_1994" xreflabel="Gamma 1994">Gamma, Erich, Richard Helm, Ralph
      Johnson, and John Vlissides. <quote>Design patterns: elements of reusable object-oriented
        software.</quote> Boston, MA: Addison-Wesley, 1994.</bibliomixed>
    <bibliomixed xml:id="kay_2008" xreflabel="Kay 2008">Kay, Michael, <emphasis role="ital">XSLT 2.0
        and XPath 2.0 programmer’s reference</emphasis>, 4th edition, Indianapolis: Wiley/Wrox,
      2008.</bibliomixed>
    <bibliomixed xml:id="kay_2009" xreflabel="Kay 2009">Kay, Michael. <quote>You pull, I’ll push: on
        the polarity of pipelines.</quote> Presented at <emphasis role="ital">Balisage: The Markup
        Conference 2009, Montréal, Canada, August 11 - 14, 2009.</emphasis> In <emphasis role="ital"
        >Proceedings of Balisage: The Markup Conference 2009. Balisage series on markup
        technologies, vol. 3 (2009). DOI: 10.4242/BalisageVol3.Kay01.</emphasis>
      <link>https://www.balisage.net/Proceedings/vol3/html/Kay01/BalisageVol3-Kay01.html</link></bibliomixed>
    <bibliomixed xml:id="kiparsky_1973" xreflabel="Kiparsky 1973">Kiparsky, Paul. Abstractness,
      opacity, and global rules. In , O. Fujimura, ed, <emphasis role="ital">Three dimensions of
        linguistic theory</emphasis>, pages 57–86. Tokyo: TEC, 1973.</bibliomixed>
    <bibliomixed xml:id="knuth_1974" xreflabel="Knuth 1974">Kunth, Donald E. <quote>Structured
        programming with <code>go to</code> statements</quote>, Computing surveys 6(4): 261–301.
        <link>http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf</link></bibliomixed>
    <bibliomixed xml:id="novatchev_2010" xreflabel="Novatchev 2010">Novatchev, Dimitre. Response to
        <quote>Is daisy chaining xslt an accepted practice?</quote>
      <link>http://stackoverflow.com/questions/4571956/is-daisy-chaining-xslt-an-accepted-practice</link></bibliomixed>
    <bibliomixed xml:id="koenig_1995" xreflabel="Koenig 1995"><quote>Patterns and
        antipatterns.</quote>
      <emphasis role="ital">Journal of object-oriented programming</emphasis> 8(1): 46-48
      (1995)</bibliomixed>
    <bibliomixed xml:id="pyfunctional" xreflabel="PyFunctional">PyFunctional (Python package).
        (<link>https://github.com/EntilZha/PyFunctional</link>)</bibliomixed>
    <bibliomixed xml:id="mcilroy_1964" xreflabel="McIlroy 1964"><quote>The origin of Unix
        pipes,</quote> Bell Labs document archive.
      <link>http://doc.cat-v.org/unix/pipes/</link></bibliomixed>
    <bibliomixed xml:id="piez_2016" xreflabel="Piez 2016">Piez, Wendell. <quote>Framing the problem:
        building customized editing environments and workflows.</quote> Presented at <emphasis
        role="ital">Balisage: The Markup Conference 2016, Washington, DC, August 2 - 5,
        2016.</emphasis> In <emphasis role="ital">Proceedings of Balisage: The Markup Conference
        2016. Balisage series on markup technologies</emphasis>, vol. 17 (2016). DOI:
      10.4242/BalisageVol17.Piez01.
        <link>https://www.balisage.net/Proceedings/vol17/html/Piez01/BalisageVol17-Piez01.html</link></bibliomixed>
    <bibliomixed xml:id="piez_2014" xreflabel="Piez 2014">Piez, Wendell. Response to <quote>Ignoring
        ambiguous
        matches.</quote><link>https://www.oxygenxml.com/archives/xsl-list/201402/msg00085.html</link></bibliomixed>
    <bibliomixed xml:id="sugrue_2010" xreflabel="Sugrue 2010">Sugrue, James. <quote>Visitor pattern
        tutorial with Java examples.</quote>
      <link>https://dzone.com/articles/design-patterns-visitor</link></bibliomixed>
    <bibliomixed xml:id="python-join" xreflabel="Why"><quote>Why is join() a string method instead
        of a list or tuple method?</quote> Part of the <emphasis role="ital">[Python] Design and
        history FAQ.</emphasis>
      <link>https://docs.python.org/3/faq/design.html#why-is-join-a-string-method-instead-of-a-list-or-tuple-method</link>
    </bibliomixed>
    <bibliomixed xml:id="XProc" xreflabel="Xproc">XProc: An XML Pipeline Language.
        <link>https://xproc.org/</link></bibliomixed>
  </bibliography>
</article>
