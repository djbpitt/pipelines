<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="balisage-1-3.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-stylesheet type="text/xsl" href="balisage-proceedings-html.xsl"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Patterns and antipatterns in micropipelining within XSLT</title>
  <info>
    <abstract>
      <para>This report explores patterns and antipatterns for pipelining functions within an XSLT
        stylesheet. The program logic of pipelining can often be expressed most directly by nesting
        functions within one another, but code that depends on nested functions may quickly become
        unreadable, especially if the number of functions is large or if they accept multiple
        parameters. This report examines alternative structural and syntactic expressions of
        processing pipelines.</para>
    </abstract>
    <author>
      <personname>
        <firstname>David</firstname>
        <othername>J.</othername>
        <surname>Birnbaum</surname>
      </personname>
      <personblurb>
        <para>David J. Birnbaum is Professor and Chair of the Department of Slavic Languages and
          Literatures at the University of Pittsburgh. He has been involved in the study of
          electronic text technology since the mid-1980s, has delivered presentations at a variety
          of electronic text technology conferences, and has served on the board of the Association
          for Computers and the Humanities, the editorial board of <emphasis role="ital">Markup
            languages: Theory and practice</emphasis>, and the Text Encoding Initiative Council.
          Much of his electronic text work intersects with his research in medieval Slavic
          manuscript studies, but he also often writes about issues in the philosophy of
          markup.</para>
      </personblurb>
      <affiliation>
        <jobtitle>Professor and Chair</jobtitle>
        <orgname>Department of Slavic Languages and Literatures, University of Pittsburgh</orgname>
      </affiliation>
      <email>djbpitt@gmail.com</email>
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest"
        >http://www.obdurodon.org</link>
    </author>
    <keywordset role="author">
      <keyword>pipeline</keyword>
    </keywordset>
  </info>
  <section>
    <title>Pipelining and micropipelining: an introduction</title>
    <para><emphasis role="bold">Pipelining</emphasis> describes the process of using the output of a
      function or similar operation as the input to a subsequent function or similar operation. For
      example, if we wish to convert a string to upper case and normalize white space within it, we
      can pass our original input string through a pipeline that combines the XPath
        <code>upper-case()</code> and <code>normalize-space()</code> functions in either order. If
      our original input string reads <code>Hi,&#xa0;&#xa0;Mom!</code> (with two spaces between the
      words), we can first apply the <code>upper-case()</code> function (yielding
        <code>HI,&#xa0;&#xa0;MOM!</code>, still with two spaces between the words) and then use the
      output of applying the <code>upper-case()</code> function as input into the
        <code>normalize-space()</code> function, which collapses the two consecutive space
      characters into one. Or we can apply the functions in the opposite order. In this example and
      many other pipelines, the order in which the functions are applied does not affect the result;
      for a situation where it does, see the discussion of character-set conversion, below.</para>
    <para>Pipes and pipelines trace their origin as a dominant process-control architecture to a
      typed note by Doug McIlroy in 1964, a summary of <quote>what’s most important</quote> that
      says that <quote>We should have some ways of coupling programs like garden hose—screw in
        another segment when it becomes when it becomes necessary to massage data in another
        way</quote>.<xref linkend="mcilroy_1964"/> In an XSLT and XQuery context:<blockquote>
        <para>Constructing an application in the form of a pipeline has many advantages, the main
          ones being (a) that the code of each step in the pipeline is kept very simple; (b) that it
          is very easy to assemble an application from a set of components, thus maximizing the
          potential for component reuse, and (c) there is no requirement that each step in a
          pipeline should use the same technology; it's easy to mix XSLT, XQuery, Java and so on in
          different stages.</para>
        <para>A number of products are available to assist with the development and management of
          pipeline-based applications, examples being Orbeon [Orbeon] and Apache Cocoon [Cocoon].
          More recently W3C has developed a standard language, XProc [W3C XProc], for the definition
          of pipelines.<xref linkend="kay_2009"/></para>
      </blockquote></para>
    <para>Beyond using the output of one process as input to the next, pipelining affords
      computational efficiency by making it possible to stream the flow of information, potentially
      avoiding the overhead of building complete intermediate structures in memory or writing
      intermediate output of the first process to disk and then reading it from disk into the input
      of the next process. Whether an application takes advantage of this possibility depends on the
      implementation, but although pipelining is similar in some respects to saving and reusing
      intermediate results, in a functional environment that supports streaming and multiprocessing,
      it has the potential of offering performance benefits by eschewing the creation of
      intermediate storage objects in variables or in disk files and permitting data to be processed
      as soon as it and a processing core become available.</para>
  </section>
  <section>
    <title>Patterns and antipatterns</title>
    <para>The term <emphasis role="bold">pattern</emphasis> refers to a generalizable way of
      addressing a common and generalizable type of problem. It is used widely in object-oriented
      programming (see, for example, <xref linkend="gamma_1994"/>), but it is not restricted to that
      domain, and in this presentation the generalizable problem we care about is pipelining in
      XSLT, and the generalizable strategies that are commonly employed to deal with it are our
      patterns. The term <emphasis role="bold">antipattern</emphasis> was introduced by Andrew
      Koenig in 1995 to describe something that looks like a paradigm for a solution to a common
      type of problem, that is, a pattern, but that for structural reasons leads to results that do
      not live up to <quote>best practice</quote> expectations.<xref linkend="koenig_1995"/> As used
      in this report, the distinction between patterns and antipatterns helps us focus on the
      strengths and weaknesses of alternative strategies for pipelining within XSLT.</para>
    <para>It is often said that code is read more often than it is written, and from that
      perspective, legibility, which contributes to ease of maintenance, is one feature that can
      distinguish patterns from antipatterns. Another is computational complexity, and in that sense
      scalability is another such feature (but see immediately below).<footnote>
        <para>Donald Knuth’s oft-cited statement that <quote>premature optimization is the root of
            all evil</quote> does not blanketly disparage optimization. The full sentence reads: <blockquote>
            <para>Programmers waste enormous amounts of time thinking about, or worrying about, the
              speed of noncritical parts of their programs, and these attempts at efficiency
              actually have a strong negative impact when debugging and maintenance are considered.
              We <emphasis role="ital">should</emphasis> forget about small efficiencies, say about
              97% of the time: premature optimization is the root of all evil.</para>
            <para>Yet we should not pass up our opportunities in that critical 3%.<xref
                linkend="knuth_1974"/> (268; see also the larger context on that page)</para>
          </blockquote></para>
      </footnote> And <xref linkend="kay_2009"/>, in a discussion of Jackson Structured Programming,
      writes that <quote>[t]he essential principle of JSP was the idea that the structure of the
        program should mirror the structure of the data</quote>, continuing that JSP can contribute
      to both code legibility and maintenance, on the one hand, and operational efficiency, on the
      other: </para>
    <blockquote>
      <para>[T]he user achieves the benefits that come from writing the application as a controlling
        application (maintainability, readability, reusability) combining these with the
        improvements in system performance that come from using a push-based control model.</para>
    </blockquote>
    <para>The boundary between a pattern and an antipattern is not always unambiguous. Some
      programming strategies discussed below are easy to write and read in simple situations, but
      may scale poorly as the complexity of the context increases. Such models might be sensible
      patterns in those simpler situations, while transforming themselves gradually into
      antipatterns as the context becomes more complex. Scalability may be a useful feature in a
      pattern, but the strategy that is best at a high degree of contextual complexity is not
      necessarily best in simpler situations. For that reason, the discussion below avoids labeling
      specific solutions globally as pattern or antipattern, and instead discusses both the
      strengths and weaknesses of each, with attention to the programming context.</para>
  </section>
  <section>
    <title>Micropipelining in context</title>
    <para>Pipelining may play a role in XSLT development at at least three levels: 1) internally,
      within the XSLT processor; 2) between or across stylesheets; and 3) within a single
      stylesheet. We describe these below by way of providing an overview; the remainder of this
      report then concentrates on only the last of the three, on pipelining within a single XSLT
      stylesheet.</para>
    <section>
      <title>1. Pipelining within the XSLT processor</title>
      <para>To the typical XSLT developer, pipelining within the XSLT processor is a black box. Not
        only can optimizations within an XSLT processor transform XSLT instructions into internal
        operations that achieve the same results by following different execution logic, but the
        largely declarative XSLT programming paradigm means that the order employed by the processor
        to execute parts of a transformation is often not entirely under the control of the XSLT
        developer. This enables an XSLT processor to improve performance by executing operations in
        parallel, a feature with consequences that sometimes surprise XSLT developers who may still
        be thinking within an imperative paradigm. For example, every new XSLT programmer has tried
        at some point to profile a stylesheet by inserting the <code>current-dateTime()</code> or
          <code>current-time()</code> function before and after an operation of interest, only to be
        surprised when the operation appears to take no time at all! This happens because there is
        no promise in the XSLT processing model that these functions will be executed in the order
        in which they appear in the XSLT code, and for that reason XSLT was designed to follow a
        functional programming paradigm here:<blockquote>
          <para>In XSLT 2.0 it is defined that multiple calls on <code>current-dateTime()</code> and
            the other two [time and date] functions will return the same result every time they are
            called within a single transformation. This means that you can’t call the function at
            the beginning and end of the transformation to measure the elapsed time. The reason for
            this rule is that XSLT is rather purist about being a strictly functional language, and
            in a strictly functional language, calling the same function twice with the same
            arguments always returns the same result. This property makes life much simpler for
              optimizers.<xref linkend="kay_2009"/> (738)</para>
        </blockquote></para>
      <para>This fact of XSLT implementation means that although the XSLT developer might write code
        that is amenable to pipelined execution, whether the pipeline is executed efficient is at
        least partially dependent on processor-internal code to which the XSLT developer has no
        direct access. When Michael Kay’s alliteratively titled <quote>You pull, I’ll push: on the
          polarity of pipelines</quote>, cited above, continues that:<blockquote>
          <para>For performance, the stages of a pipeline should communicate by means of streams of
            events. Traditionally, this can be done either by writing components with pull polarity
            (the consumer calls the supplier when data is required), or by components with push
            polarity (the supplier calls the consumer when data is available). <emphasis role="ital"
              >Performance problems arise when components with different polarity are mixed within
              the same pipeline.</emphasis><xref linkend="kay_2009"/> (emphasis added)</para>
        </blockquote></para>
      <para>any aspect of the polarity that is determined within the XSLT processor, rather than
        within the XSLT code, is at least partially outside the control of the XSLT developer. In
        this XSLT-developer-focused report, pipelining within the XSLT processor will not be
        discussed further.</para>
    </section>
    <section>
      <title>2. Pipelining between and across stylesheets</title>
      <para>An aspect of pipelining that is fully under the control of the XSLT developer is
        pipelining between or across XSLT stylesheets. A complex transformation might be broken down
        into simpler stages, where each stage is implemented in a separate XSLT stylesheet, and
        interim results are written to disk by one process and then read from disk by another. This
        strategy may make the individual stylesheets easier to read because each may implement only
        a small and coherent aspect of the overall transformation, and it also makes it easy to
        examine the intermediate output during development, and to develop each step of the pipeline
        without distraction by what precedes or follows. But disk I/O is much slower than in-memory
        access, and the cost of writing the intermediate files is likely to compromise severely the
        efficiency of the transformation. Whether that matters it likely to depend on the volume of
        data; augmenting the execution time by an order of magnitude may not matter to the developer
        if the overall time is still subjectively brief.</para>
      <para>The overhead of disk I/O can be avoided by using pipelining utilities, whether general
        purpose (such as Apache Cocoon<xref linkend="cocoon"/>) or XML specific (XProc<xref
          linkend="XProc"/>). Pipelining tools avoid the overhead of disk I/O, although whether they
        build complete intermediate in-memory structures or decompose (and perhaps parallelize) the
        transformation in a functional manner is implementation-specific. XProc has been the subject
        of six presentations by six different authors or teams of authors at Balisage alone (see
          <link>https://www.balisage.net/Proceedings/topics/XProc.html</link>), and Cocoon has also
        made several appearances, including as part of the toolkit used to produce the Balisage
        proceedings (<link>https://www.balisage.net/Proceedings/vol17/acknowledgements.html</link>).
        Pipelining between or across XSLT stylesheets with technologies like Cocoon or XProc does
        not prohibit writing intermediate output to disk for examination during debugging, but it
        does not require it, and XProc in particular incorporates additional features that may be
        useful in complex transformations of XML documents (see
          <link>https://www.w3.org/TR/xproc/#pipeline-concepts</link>). The focus of the current
        report is on micropipelining, that is, on pipelines implemented within a single XSLT
        stylesheet, and we will not explore XProc or other technologies for pipelining between or
        across stylesheets, except to note that whether to implement a pipeline within a single
        stylesheets or between or across stylesheets is a separate consideration that is beyond the
        scope of the present report.</para>
    </section>
    <section>
      <title>3. Micropipelining: pipelining within a single XSLT stylesheet</title>
      <para>We use the term <emphasis role="bold">micropipelining</emphasis> to refer to pipelining
        within a single XSLT stylesheet. Micropipelines implemented within a single stylesheet can
        always be refactored and spread across multiple stylesheets, but in situations where the
        steps are conceptually part of what a human would consider a single operation, and where
        intermediate stages are unlikely to be important except for debugging purposes, combining
        them within a single XSLT stylesheet that performs that single operation may make for easier
        implementation and maintenance.</para>
      <para>The application that motivated this exploration is connected to our use of XML
        technologies to identify and analyze meter and rhyme in Russian verse. We presented a report
        on the identification of meter at Balisage 2015 (<xref linkend="birnbaum_2015"/>), and in
        order also to identify rhyme we need to convert normal Russian orthography to a phonetic
        representation. As long as the place of stress is known (and that information was provided
        as part of the analysis of meter), the phonetic conversion turns out to be easier in Russian
        than in English because Russian orthography, although not phonetic, is closer to the
        phonetics of the language than is the case with English.</para>
      <para>It is common in historical linguistics to describe language change in terms of the
        application of ordered rules as a pipeline that accepts an initial form as input, pipes it
        through a sequence of individual sound-change rules, and generates transformed output.
        Constraints on the order in which rules apply are traditionally described using alimentary
        and sanguinary metaphors, and they are based on the linguistic reality that sound change may
        happen at a certain point in history and then cease to operate, that is, cease to be a
        productive process:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Feeding order.</emphasis> The output of one rule creates new
            input for another rule. For example, if in Rule A <emphasis role="ital">x → y</emphasis>
            (read as <emphasis role="ital">x</emphasis> is transformed into <emphasis role="ital"
              >y</emphasis>) and in Rule B <emphasis role="ital">y → z</emphasis>, Rule A feeds Rule
            B by creating new input for it.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Bleeding order.</emphasis> The output of one rule modifies a
            form that would otherwise have served as input for another rule. For example, if in Rule
            A <emphasis role="ital">z → q</emphasis> and in Rule B <emphasis role="ital">x → y / _
              z</emphasis> (read as <emphasis role="ital">x</emphasis> is transformed into <emphasis
              role="ital">y</emphasis> when it precedes <emphasis role="ital">z</emphasis>), Rule A
            is said to bleed Rule B because it reduces the application of Rule B by the destroying
            the environment it requires.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Counter-feeding order.</emphasis> The output of one rule does
            not create new input for another rule, but were the order of the two rules reversed,
            they would observe a feeding relationship. For example, if in Rule A <emphasis
              role="ital">y → z</emphasis> and in Rule B <emphasis role="ital">x → y</emphasis>, the
            two stand in a counter-feeding relationship, since Rule B creates what would have been
            new input into Rule A, but fails to do so because Rule A operates first, and is no
            longer active when the potential new input is created by Rule B.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Counter-bleeding order.</emphasis> The output of one rule does
            not bleed forms that might otherwise have served as input for another rule, but were the
            order of the two rules reversed, they would observe a bleeding relationship. For
            example, if in Rule A <emphasis role="ital">x → y / _ z</emphasis> and in Rule B
              <emphasis role="ital">z → q</emphasis>, the rules observe a counter-bleeding order
            because were the order reversed, Rule B would reduce the applicability of Rule A by
            destroying the context it requires.</para>
        </listitem>
      </itemizedlist>
      <para>Note that feeding and bleeding are not opposites, and that some rules may not be
        critically ordered with respect to others because their input and output does not intersect
        with the input and output of other rules. These types of relationships among rules are
        important because of their role in directing or constraining linguistic change (see, for
        example, <xref linkend="kiparsky_1973"/>). In the context of the present report, they also
        provide a vocabulary for discussing the interaction of XPath functions and XSLT templates
        when those are used to implement transformations that model linguistic processes. Feeding,
        bleeding, and their opposites are appropriate for modeling historical language change
        because history imposes a real chronological order, but a similar model that uses similar
        terminology may be used to describe other linguistic phenomena, including the synchronic
        derivation of surface forms from more abstract underlying forms. In the present instance, we
        employ it to describe, as a pipeline of individual rules, the transformation of standard
        Russian orthography (which is not phonetic) to a phonetic representation that can serve as
        the basis for identifying rhyme in verse.</para>
    </section>
  </section>
  <section>
    <title>Micropipelining: a closer look</title>
    <section>
      <title>Convenience variables</title>
      <para>Stuff about convenience variables</para>
    </section>
    <section>
      <title>Nested functions</title>
      <para>Stuff about nested functions, Chaining. Map. With and without variables.</para>
    </section>
    <section>
      <title>Calling templates</title>
      <para>Stuff about calling templates</para>
    </section>
    <section>
      <title>The visitor pattern</title>
      <para>Stuff about the visitor pattern</para>
    </section>
    <section>
      <title>nested calls to the replace() functions</title>
      <para>Stuff about character-set conversion using table-driven sibling recursion with
        replace()</para>
    </section>
  </section>
  <section>
    <title>Conclusion</title>
    <para>Generalizations</para>
  </section>
  <section>
    <title>Stuff</title>
    <para>I read Michael's article with interest, and especially the observation that the processing
      quagmire isn't push or pull, but transitions (in either direction) between them. Michael
      writes about the inner workings of Saxon, with the idea of avoiding the overhead of creating
      intermediate structures by streaming that which is streamable. For the rest of us, though,
      although Michael advises us about how to write code that is capable of operating without
      building an interim tree in memory (or other inefficiencies), whether our code takes advantage
      of the potential for efficiency is largely inside the black box. And while Michael has put a
      window in the box, it still operates at a lower level, one that invites us to operate on its
      terms, but where only a Java programmer with access to the source code can control whether it
      turns our potentially efficient code into real efficiency. None of this problematic; it just
      reminds me that the end-user benefits from cooperating with the efficiencies available in the
      application, but ultimately optimization is out of our control.</para>
    <para>What I've been thinking of in connection with pipelining grows out of our earlier
      correspondence about the "visitor pattern" (which I had never heard of previously) and related
      issues. The challenge I was trying to address was that a single XSLT stylesheet affords
      several ways of building pipelines, each of which has its own advantages and disadvantages
      with respect to legibility and ease of use (for the coder), which are a higher priority for me
      than execution efficiency (see below). For example, function1(function2(function3(input)))
      invites misplaced punctuation, especially as the number of embedded functions grows and if any
      of the functions takes more than one argument. Template processing benefits from isolating
      each operation, similarly to functional decomposition, but it's difficult to see the entire
      pipeline at a glance. The visitor pattern that you recommended is more legible (and therefore
      manageable) than either of the alternatives, but it operates at an additional level of
      abstraction that keeps it from being intuitive (which is a solipsistic way of saying that it
      didn't occur to me as an option until you suggested it). Along a different thread that's part
      of the same garment, I often need to transform someone else's gnarly non-Unicode slop into
      Unicode, and the character mappings may be a combination of one-to-one, one-to-many,
      many-to-one, and many-to-many. Some of operations are critically ordered for reasons that in
      linguistics are termed "feeding" and "bleeding"; others can happen in any order. I've
      developed a table-driven approach for managing these types of transformations, which I don't
      consider especially profound or clever, but it does improve legibility over explicit nested
      function calls. The table-driven approach calls a replace() function by running sibling
      recursion on the mapping table (with a few details to accommodate order constraints), and the
      table is legible in the same way as the list of template invocations in the visitor strategy.
      My character-mapping operation finishes with the dynamic construction of arguments 2 and 3 to
      translate() to handle the one-to-one mappings at the end of the process; those could
      alternatively be handled by continuing the replace() pipeline, but translate() is more
      efficient, and it has other advantages for one-to-one mapping (such as the ability to do
      translate($stuff,'xy','yx') without having to create an intermediate representation to avoid
      unwanted feeding of one replacement into another.</para>
    <para>As I've been crafting bespoke solutions to these types of pipelining problems over the
      years, I've wished for a tutorial that would list the options, say something smart about the
      advantages and disadvantages of each, point out where they behave similarly or differently
      from one another, and perhaps make recommendations for deciding among them in the field. That
      tutorial is the vague target I had in mind for a Balisage submission. I was less interested in
      the scalability and streamability on which Michael focuses not only because I don't control
      what happens inside the black box, but also because in my world the data have never been so
      voluminous that my coffee has gotten cold while I waited for a transformation to run to
      completion. So while computational efficiency is self-evidently better than computational
      inefficiency, legibility is of more value to me, since otherwise I lose more time trying to
      understand my code than I lose running it.</para>
    <para>The essential principle of JSP was the idea that the structure of the program should
      mirror the structure of the data. (Kay 2009)</para>
  </section>
  <!-- Kay 2009: "Performance problems arise when components with different polarity are mixed within the same pipeline." -->
  <bibliography>
    <title>Works cited</title>
    <bibliomixed xml:id="cocoon" xreflabel="Cocoon">Apache Cocoon.
        <link>http://cocoon.apache.org/</link></bibliomixed>
    <bibliomixed xml:id="birnbaum_2015" xreflabel="Birnbaum 2015">Birnbaum, David J., and Elise
      Thorsen. <quote>Markup and meter: Using XML tools to teach a computer to think about
        versification.</quote> Presented at Balisage: The Markup Conference 2015, Washington, DC,
      August 11 - 14, 2015. In <emphasis role="ital">Proceedings of Balisage: The Markup Conference
        2015.</emphasis> Balisage Series on Markup Technologies, vol. 15 (2015). DOI:
      10.4242/BalisageVol15.Birnbaum01.
        <link>https://www.balisage.net/Proceedings/vol15/html/Birnbaum01/BalisageVol15-Birnbaum01.html</link></bibliomixed>
    <bibliomixed xml:id="fuller_2016" xreflabel="Fuller 2016">Fuller, James. <quote>A catalog of
        functional programming idioms in XQuery 3.1.</quote> Presented at <emphasis role="ital"
        >Balisage: The Markup Conference 2016, Washington, DC, August 2 - 5, 2016.</emphasis> In
      Proceedings of Balisage: The Markup Conference 2016. <emphasis role="ital">Balisage series on
        markup technologies,</emphasis> vol. 17 (2016). DOI: 10.4242/BalisageVol17.Fuller01.
        <link>https://www.balisage.net/Proceedings/vol17/html/Fuller01/BalisageVol17-Fuller01.html</link></bibliomixed>
    <bibliomixed xml:id="gamma_1994" xreflabel="Gamma 1994">Gamma, Erich, Richard Helm, Ralph
      Johnson, and John Vlissides. <quote>Design patterns: elements of reusable object-oriented
        software.</quote> Boston, MA: Addison-Wesley, 1994.</bibliomixed>
    <bibliomixed xml:id="kay_2009" xreflabel="Kay 2009">Kay, Michael. <quote>You pull, I’ll push: on
        the polarity of pipelines.</quote> Presented at <emphasis role="ital">Balisage: The Markup
        Conference 2009, Montréal, Canada, August 11 - 14, 2009.</emphasis> In <emphasis role="ital"
        >Proceedings of Balisage: The Markup Conference 2009. Balisage series on markup
        technologies, vol. 3 (2009). DOI: 10.4242/BalisageVol3.Kay01.</emphasis>
      <link>https://www.balisage.net/Proceedings/vol3/html/Kay01/BalisageVol3-Kay01.html</link></bibliomixed>
    <bibliomixed xml:id="kiparsky_1973" xreflabel="Kiparsky 1973">Kiparsky, Paul. Abstractness,
      opacity, and global rules. In , O. Fujimura, ed, <emphasis role="ital">Three dimensions of
        linguistic theory</emphasis>, pages 57–86. Tokyo: TEC, 1973.</bibliomixed>
    <bibliomixed xml:id="knuth_1974" xreflabel="Knuth 1974">Kunth, Donald E. <quote>Structured
        programming with <code>go to</code> statements</quote>, Computing surveys 6(4): 261–301.
        <link>http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf</link></bibliomixed>
    <bibliomixed xml:id="koenig_1995" xreflabel="Koenig 1995"><quote>Patterns and
        antipatterns.</quote>
      <emphasis role="ital">Journal of object-oriented programming</emphasis> 8(1): 46-48
      (1995)</bibliomixed>
    <bibliomixed xml:id="mcilroy_1964" xreflabel="McIlroy 1964"><quote>The origin of Unix
        pipes,</quote> Bell Labs document archive.
      <link>http://doc.cat-v.org/unix/pipes/</link></bibliomixed>
    <bibliomixed xml:id="piez_2016" xreflabel="Piez 2016">Piez, Wendell. <quote>Framing the problem:
        building customized editing environments and workflows.</quote> Presented at <emphasis
        role="ital">Balisage: The Markup Conference 2016, Washington, DC, August 2 - 5,
        2016.</emphasis> In <emphasis role="ital">Proceedings of Balisage: The Markup Conference
        2016. Balisage series on markup technologies</emphasis>, vol. 17 (2016). DOI:
      10.4242/BalisageVol17.Piez01.
        <link>https://www.balisage.net/Proceedings/vol17/html/Piez01/BalisageVol17-Piez01.html</link></bibliomixed>
    <bibliomixed xml:id="XProc" xreflabel="Xproc">XProc: An XML Pipeline Language.
        <link>https://xproc.org/</link></bibliomixed>
  </bibliography>
</article>
