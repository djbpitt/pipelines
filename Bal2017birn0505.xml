<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="balisage-1-3.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-stylesheet type="text/xsl" href="balisage-proceedings-html.xsl"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Patterns and antipatterns in micropipelining within XSLT</title>
  <info>
    <abstract>
      <para>This report explores patterns and antipatterns for pipelining functions within an XSLT
        stylesheet. The program logic of pipelining can often be expressed most directly by nesting
        functions within one another, but code that depends on nested functions may quickly become
        unreadable, especially if the number of functions is large or if they accept multiple
        parameters. This report examines alternative structural and syntactic expressions for
        processing pipelines.</para>
    </abstract>
    <author>
      <personname>
        <firstname>David</firstname>
        <othername>J.</othername>
        <surname>Birnbaum</surname>
      </personname>
      <personblurb>
        <para>David J. Birnbaum is Professor and Chair of the Department of Slavic Languages and
          Literatures at the University of Pittsburgh. He has been involved in the study of
          electronic text technology since the mid-1980s, has delivered presentations at a variety
          of electronic text technology conferences, and has served on the board of the Association
          for Computers and the Humanities, the editorial board of <emphasis role="ital">Markup
            languages: Theory and practice</emphasis>, and the Text Encoding Initiative Council.
          Much of his electronic text work intersects with his research in medieval Slavic
          manuscript studies, but he also often writes about issues in the philosophy of
          markup.</para>
      </personblurb>
      <affiliation>
        <jobtitle>Professor and Chair</jobtitle>
        <orgname>Department of Slavic Languages and Literatures, University of Pittsburgh</orgname>
      </affiliation>
      <email>djbpitt@gmail.com</email>
      <link xlink:type="simple" xlink:show="new" xlink:actuate="onRequest"
        >http://www.obdurodon.org</link>
    </author>
    <keywordset role="author">
      <keyword>pipeline</keyword>
    </keywordset>
  </info>
  <section>
    <title>Pipelining and micropipelining</title>
    <para><emphasis role="bold">Pipelining</emphasis> describes the process of using the output of a
      function or other operation as the input to a subsequent function or other operation. As an
      example of a function pipeline, if we wish to convert a string to upper case and normalize
      white space within it, we can pass our original input string through a pipeline that combines
      the XPath <code>upper-case()</code> and <code>normalize-space()</code> functions in either
      order. If our original input string reads <quote>Hi,&#xa0;&#xa0;Mom!</quote> (with two spaces
      between the words), we can first apply the <code>upper-case()</code> function (yielding
        <quote>HI,&#xa0;&#xa0;MOM!</quote>, still with two spaces between the words) and then use
      the output of applying the <code>upper-case()</code> function as input into the
        <code>normalize-space()</code> function, which collapses the two consecutive space
      characters into one. Or we can apply the functions in the opposite order. In this example and
      many other pipelines, the order in which the functions are applied does not affect the result;
      for situations where it does, see the discussion of feeding and bleeding orders, below.</para>
    <para>Pipelines may connect small, individual functions, as in the example above, or they may be
      constructed at higher levels. For example, an XSLT transformation might be designed as a
      pipeline of XSLT stylesheets, where the original input XML is passed into a transformation
      that uses one stylesheet and creates output XML, which becomes the input XML for another
      stylesheet, etc., until eventually the desired final output is created. While <emphasis
        role="bold">pipelining</emphasis> is well established as a technical term, <emphasis
        role="bold">micropipelining</emphasis> is not, and we use the latter in this report to refer
      to pipelines that operate entirely within a single XSLT stylesheet, whether at the level of
      individual functions or in some of the more complex ways described below.</para>
    <para>Pipes and pipelines trace their popularity as a process-control architecture to a 1964
      typed note by Doug McIlroy about Unix. In a summary of <quote>what’s most important</quote>,
      McIlroy writes that that <quote>[w]e should have some ways of coupling programs like garden
        hose—screw in another segment when it becomes necessary to massage data in another
        way</quote>. (<xref linkend="mcilroy_1964"/>) In an XSLT and XQuery context:<blockquote>
        <para>Constructing an application in the form of a pipeline has many advantages, the main
          ones being (a) that the code of each step in the pipeline is kept very simple; (b) that it
          is very easy to assemble an application from a set of components, thus maximizing the
          potential for component reuse, and (c) there is no requirement that each step in a
          pipeline should use the same technology; it's easy to mix XSLT, XQuery, Java and so on in
          different stages.</para>
        <para>A number of products are available to assist with the development and management of
          pipeline-based applications, examples being Orbeon [Orbeon] and Apache Cocoon [Cocoon].
          More recently W3C has developed a standard language, XProc [W3C XProc], for the definition
          of pipelines. (<xref linkend="kay_2009"/>)</para>
      </blockquote></para>
    <para>Beyond using the output of one process as input to the next, pipelining affords
      computational efficiency by making it possible to stream the flow of information, potentially
      avoiding the overhead of building complete intermediate structures in memory or writing
      intermediate output of the first process to disk and then reading it from disk into the input
      of the next process. Whether an application takes advantage of this possibility depends on the
      implementation, but although pipelining is similar in some respects (especially pertaining to
      the eventual final output) to saving and reusing intermediate results, in a functional
      environment that supports streaming and multiprocessing, it also has the potential of offering
      performance benefits by eschewing the creation of intermediate storage objects in variables or
      in disk files and permitting data to be processed as soon as it and a processing core become
      available.</para>
  </section>
  <section>
    <title>Patterns and antipatterns</title>
    <para>The term <emphasis role="bold">pattern</emphasis> refers to a generalizable way of
      addressing a common and generalizable type of problem. It is used widely in object-oriented
      programming (see, for example, <xref linkend="gamma_1994"/>), but it is not restricted to that
      domain, and in this presentation the generalizable problem we care about is pipelining in
      XSLT, and the generalizable strategies that are commonly employed to deal with it are our
      patterns. The term <emphasis role="bold">antipattern</emphasis> was introduced by Andrew
      Koenig in 1995 to describe something that looks like a paradigm for a solution to a common
      type of problem, that is, a pattern, but that for structural reasons leads to results that do
      not live up to <quote>best practice</quote> expectations. (<xref linkend="koenig_1995"/>) As
      used in this report, the distinction between patterns and antipatterns helps us focus on the
      strengths and weaknesses of alternative strategies for pipelining within XSLT.</para>
    <para>It is often said that code is read more often than it is written, and from that
      perspective, legibility, which contributes to ease of maintenance, is one feature that can
      distinguish patterns from antipatterns. Another is computational complexity, and in that
      context scalability is another such feature (but see immediately below).<footnote>
        <para>Donald Knuth’s oft-cited statement that <quote>premature optimization is the root of
            all evil</quote> does not blanketly disparage optimization. In narrow context it reads: <blockquote>
            <para>Programmers waste enormous amounts of time thinking about, or worrying about, the
              speed of noncritical parts of their programs, and these attempts at efficiency
              actually have a strong negative impact when debugging and maintenance are considered.
              We <emphasis role="ital">should</emphasis> forget about small efficiencies, say about
              97% of the time: premature optimization is the root of all evil.</para>
            <para>Yet we should not pass up our opportunities in that critical 3%. (<xref
                linkend="knuth_1974"/>, p. 268; see also the larger context on that page)</para>
          </blockquote></para>
      </footnote> And <xref linkend="kay_2009"/>, in a discussion of Jackson Structured Programming,
      writes that <quote>[t]he essential principle of JSP was the idea that the structure of the
        program should mirror the structure of the data</quote>, continuing that JSP can contribute
      to both code legibility and maintenance, on the one hand, and operational efficiency, on the
      other: </para>
    <blockquote>
      <para>[T]he user achieves the benefits that come from writing the application as a controlling
        application (maintainability, readability, reusability) combining these with the
        improvements in system performance that come from using a push-based control model.</para>
    </blockquote>
    <para>The boundary between a pattern and an antipattern is not always unambiguous. Some
      programming strategies discussed below, such as nested functions, are easy to write and read
      in simple situations (e.g., two functions, each of which takes one parameter), but may scale
      poorly with respect to legibility as the complexity of the context increases. Such models
      might therefore be sensible patterns when applied in those simpler situations, while
      transforming themselves gradually into antipatterns as the complexity of the context
      increases. Scalability may be a useful feature in a pattern, but the strategy that is best at
      a high degree of contextual complexity is not necessarily optimal in simpler situations. For
      that reason, the discussion below avoids labeling specific solutions globally as pattern or
      antipattern, and instead discusses both the strengths and weaknesses of each approach, with
      attention to the programming context. We thus use pattern and antipattern as a framework for
      evaluating the strengths and weaknesses of coding strategies, rather than as a taxonomy for
      classifying them in a binary fashion.</para>
  </section>
  <section>
    <title>Micropipelining in context</title>
    <para>Pipelining may play a role in XSLT development at at least three levels: 1) internally,
      within the XSLT processor; 2) between or across stylesheets; and 3) within a single
      stylesheet. We describe these below by way of providing a broad context and overview, but the
      focus of this report is on only the last of the three, on pipelining within a single XSLT
      stylesheet, which we call micropipelining.</para>
    <section>
      <title>1. Pipelining within the XSLT processor</title>
      <para>To the typical XSLT developer, pipelining within the XSLT processor is a black box. Not
        only can optimizations within an XSLT processor transform XSLT instructions into internal
        operations that achieve the same results by following different execution logic, but the
        largely declarative XSLT programming paradigm means that the order employed by the processor
        to execute parts of a transformation is not entirely under the control of the XSLT
        developer. This enables an XSLT processor to improve performance by executing operations in
        parallel, a feature with consequences that sometimes surprise XSLT developers who may still
        be thinking within an imperative paradigm. For example, every new XSLT programmer has tried
        at some point to profile a stylesheet by inserting the <code>current-dateTime()</code> or
          <code>current-time()</code> function before and after an operation of interest, only to be
        surprised when the operation appears to take no time at all! This happens because there is
        no promise in the XSLT processing model that these functions will be executed in the order
        in which they appear in the XSLT code, and for that reason XSLT was designed to follow a
        functional programming paradigm here:<blockquote>
          <para>In XSLT 2.0 it is defined that multiple calls on <code>current-dateTime()</code> and
            the other two [time and date] functions will return the same result every time they are
            called within a single transformation. This means that you can’t call the function at
            the beginning and end of the transformation to measure the elapsed time. The reason for
            this rule is that XSLT is rather purist about being a strictly functional language, and
            in a strictly functional language, calling the same function twice with the same
            arguments always returns the same result. This property makes life much simpler for
            optimizers. (<xref linkend="kay_2009"/>, p. 738)</para>
        </blockquote></para>
      <para>The functional aspects of XSLT mean that although an XSLT developer might write code
        that is amenable to pipelined execution, how the pipeline is executed is at least partially
        dependent on processor-internal code to which the XSLT developer has no direct access.
        Michael Kay’s alliteratively titled <quote>You pull, I’ll push: on the polarity of
          pipelines</quote>, cited above, continues that:<blockquote>
          <para>For performance, the stages of a pipeline should communicate by means of streams of
            events. Traditionally, this can be done either by writing components with pull polarity
            (the consumer calls the supplier when data is required), or by components with push
            polarity (the supplier calls the consumer when data is available). <emphasis role="ital"
              >Performance problems arise when components with different polarity are mixed within
              the same pipeline.</emphasis> (<xref linkend="kay_2009"/>, emphasis added)</para>
        </blockquote></para>
      <para>As important as this polarity is for performance, to the extent that it is determined
        within the XSLT processor, rather than within the XSLT code, it is at least partially
        outside the control of the XSLT developer. For that reason, in this XSLT-developer-focused
        report, pipelining within the XSLT processor will not be discussed further.</para>
    </section>
    <section>
      <title>2. Pipelining between and across XSLT stylesheets</title>
      <para>An aspect of pipelining that is much more under the control of the XSLT developer is
        pipelining between or across XSLT stylesheets. A complex transformation might be broken down
        into simpler stages, where each stage is implemented in a separate XSLT stylesheet, and
        interim results are written to disk by one process and then read from disk by another. This
        strategy may make the individual stylesheets easier to read because each may implement only
        a small and coherent aspect of the overall transformation. This approach also makes it easy
        to examine the intermediate output during development, and to develop each step of the
        pipeline without distraction by what precedes or follows. But disk I/O is much slower than
        in-memory access, and the cost of writing the intermediate files is likely to compromise
        severely the efficiency of the transformation. Whether that matters it likely to depend on
        the volume of data; augmenting the execution time by an order of magnitude may not matter to
        the developer if the overall time is still subjectively brief.</para>
      <para>The overhead of disk I/O can be avoided by using pipelining utilities, whether broader
        purpose (such as Apache Cocoon [<xref linkend="cocoon"/>]) or more narrowly XML specific
        (XProc [<xref linkend="XProc"/>]). Pipelining tools avoid the overhead of disk I/O, although
        whether they build complete intermediate in-memory structures or decompose (and perhaps
        parallelize or stream) the transformation in a functional manner is implementation-specific.
        These technologies are well know to the Balisage audience: XProc has been the subject of six
        presentations by six different authors or teams of authors at Balisage alone (see
          <link>https://www.balisage.net/Proceedings/topics/XProc.html</link>), and Cocoon has also
        made several appearances, including as part of the toolkit used to produce the Balisage
        proceedings (<link>https://www.balisage.net/Proceedings/vol17/acknowledgements.html</link>).
        Pipelining between or across XSLT stylesheets with technologies like Cocoon or XProc does
        not prohibit writing intermediate output to disk for examination during debugging, but it
        does not require it, and XProc in particular incorporates additional features that may be
        useful in complex transformations of XML documents (see
          <link>https://www.w3.org/TR/xproc/#pipeline-concepts</link>). The focus of the current
        report is on micropipelining, that is, on pipelines implemented within a single XSLT
        stylesheet, and we will not explore XProc or other technologies for pipelining between or
        across stylesheets, except to note that whether to implement a pipeline within a single
        stylesheet or between or across stylesheets is a separate consideration that lies outside
        the within-stylesheet scope of the present report.</para>
    </section>
    <section>
      <title>3. Micropipelining: pipelining within a single XSLT stylesheet</title>
      <para>As mentioned above, we use the term micropipelining to refer to pipelining within a
        single XSLT stylesheet. Micropipelines implemented within a single stylesheet can always be
        refactored and spread across multiple stylesheets, but in situations where the steps are
        conceptually part of what a human would consider a single operation, and where intermediate
        stages are unlikely to be of interest except for debugging purposes during development,
        combining them within a single XSLT stylesheet that performs that single operation may make
        for easier implementation and maintenance.</para>
      <para>The application that motivated this exploration is connected to our use of XML
        technologies to identify and analyze meter and rhyme in Russian verse. We presented a report
        on the identification of meter at Balisage 2015 (<xref linkend="birnbaum_2015"/>), and in
        order also to identify rhyme we need to convert normal Russian orthography to a phonetic
        representation. As long as the place of stress is known,<footnote>
          <para>The place of stress in Russian, as in English, is not normally indicated
            orthographically, and because stress can fall on different syllables in different words,
            it is not predictable without lexical knowledge. The identification of meter depends on
            knowing the place of stress, and <xref linkend="birnbaum_2015"/> describes how stress is
            added automatically to augment unstressed input in natural Russian orthography before
            performing metrical analysis.</para>
        </footnote> the phonetic conversion, although complex, turns out to be easier in Russian
        than in English because Russian orthography, although not phonetic, is closer to the
        phonetics of the language than is the case with English.</para>
      <para>It is common in historical linguistics to describe language change in terms of the
        application of ordered rules as a pipeline that accepts an initial form as input, pipes it
        (that is, passes it along) through a sequence of individual sound-change rules, and
        generates transformed output. Constraints on the order in which rules apply are
        traditionally described using alimentary and sanguinary metaphors, and they are based on the
        linguistic realities that sound change may happen at a certain point in history and then
        cease to operate, that is, cease to be a productive process:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Feeding order.</emphasis> The output of one rule creates new
            input for another rule. For example, if in Rule A <emphasis role="ital">x → y</emphasis>
            (read as <emphasis role="ital">x</emphasis> is transformed into <emphasis role="ital"
              >y</emphasis>) and in Rule B <emphasis role="ital">y → z</emphasis>, Rule A feeds Rule
            B by creating new input for it.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Bleeding order.</emphasis> The output of one rule modifies a
            form that would otherwise have served as input for another rule. For example, if in Rule
            A <emphasis role="ital">z → q</emphasis> and in Rule B <emphasis role="ital">x → y / _
              z</emphasis> (read as <emphasis role="ital">x</emphasis> is transformed into <emphasis
              role="ital">y</emphasis> when it precedes <emphasis role="ital">z</emphasis>), Rule A
            is said to bleed Rule B because it reduces the application of Rule B by the destroying
            the environment it requires.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Counter-feeding order.</emphasis> The output of one rule does
            not create new input for another rule, but were the order of the two rules reversed,
            they would observe a feeding relationship. For example, if in Rule A <emphasis
              role="ital">y → z</emphasis> and in Rule B <emphasis role="ital">x → y</emphasis>, the
            two stand in a counter-feeding relationship, since Rule B creates what would have been
            new input into Rule A, but fails to do so because Rule A operates first, and is no
            longer active when the potential new input is created by Rule B.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Counter-bleeding order.</emphasis> The output of one rule does
            not bleed forms that might otherwise have served as input for another rule, but were the
            order of the two rules reversed, they would observe a bleeding relationship. For
            example, if in Rule A <emphasis role="ital">x → y / _ z</emphasis> and in Rule B
              <emphasis role="ital">z → q</emphasis>, the rules observe a counter-bleeding order
            because were the order reversed, Rule B would reduce the applicability of Rule A by
            destroying the context it requires.</para>
        </listitem>
      </itemizedlist>
      <para>Note that feeding and bleeding are not opposites, and that some rules may not be
        critically ordered with respect to others because their input, output, and conditioning
        environment do not intersect with the input, output, and conditioning environment of other
        rules. These types of relationships among rules are important because of their role in
        directing or constraining linguistic change (see, for example, <xref linkend="kiparsky_1973"
        />). In the context of the present report, these relationships also provide a vocabulary for
        discussing the interaction of XPath functions and XSLT templates when those are used to
        implement transformations that model linguistic processes. Feeding, bleeding, and their
        opposites are appropriate for modeling historical language change because history imposes a
        real chronological order, but a similar model that uses similar terminology may also
        describe other linguistic phenomena, including the synchronic derivation of surface forms
        from more abstract underlying forms. In the present instance, we employ this framework to
        describe, as a pipeline of individual rules, the XSLT implementation of a transformation of
        standard Russian orthography (which is not phonetic) to a phonetic representation that can
        serve as the basis for identifying rhyme in verse.</para>
    </section>
  </section>
  <section>
    <title>Micropipelining: a closer look</title>
    <section>
      <title>Background and context</title>
      <para>When we began implementing in XSLT the machine-assisted identification and analysis of
        Russian rhyme, we were aware that pipelining was required because our algorithm for
        converting natural Russian orthography (enhanced by information about stress, which is not
        part of natural Russian orthography) was conceptualized as a series of rules or insertion,
        deletion, and replacement, the order of which was constrained by feeding and bleeding
        relationships. What we missed was a tutorial about alternatives for implementing
        micropipelines, which might guide us toward the most effective way of developing legible,
        maintainable, and efficient code. The principal goal of the present report is to fill the
        gap by describing and illustrating the alternatives that we found most useful.</para>
    </section>
    <section>
      <title>Convenience variables</title>
      <para>As the name implies, <emphasis role="bold">convenience variables</emphasis> are
        variables created for the benefit of the programmer, and not because they necessarily
        improve the efficiency or operation of the program. The purpose of convenience variables is
        that typically they improve the legibility of the code, which makes it easier to develop
        (one piece at a time) and maintain.</para>
      <para>Variables that improve the efficiency of the transformation process itself are not
        convenience variables (although they may also be convenient). For example, if we need to
        calculate the same result more than once in an XSLT stylesheet, performing the calculation
        only once and saving it in a variable that we can then reuse may reduce the amount of
        computation and improve the performance of the transformation. On the other hand, when we
        calculate a value that we will use only once, save it in a variable, and then use the
        variable, not only is there no similar saving, but we actually risk reducing the efficiency
        of the transformation by imposing the overhead needed to create the variable as an
        intermediate structure. Within XSLT, this is especially the case when variables are declared
        without explicit typing using the <code>@as</code> attribute, which results in the expensive
        creation of a temporary in-memory document (that we may not need) to hold the value.<footnote>
          <para><quote>If a sequence constructor is used with no <code>as</code> attribute, a
              temporary document is constructed. This is done by creating a new document node and
              using the value of the result sequence to form the children of the document
              node.</quote> (<xref linkend="kay_2008"/>, p. 503). There are times when constructing
            a temporary tree is nonetheless appropriate; for an example, see <xref
              linkend="kay_2008"/>, p. 510ff.</para>
        </footnote></para>
      <para>As an example of a convenience variable, consider an XSLT transformation to SVG where we
        need to calculate the <code>x</code> and <code>y</code> coordinates of an object and then
        plot it. If those calculations are complex, packing them into the declaration of the object
        may compromise its transparency. Compare the version with convenience variables:</para>
      <programlisting>&lt;xsl:variable name="xPos" as="xs:double" select="position() * $xScale"/&gt;
&lt;xsl:variable name="yPos" as="xs:double" select=". * $yScale"/&gt;
&lt;rect x={$xPos} y="-{$yPos}" width="{$width}" height="{$yPos}"/></programlisting>
      <para>to one without:</para>
      <programlisting>&lt;rect x={position() * $xScale} y="-{. * $yScale}" width="{$width}" height="{. * $yScale}"/></programlisting>
      <para>The more complex the calculation, the more the legibility may be improved through the
        use of convenience variables.<footnote>
          <para>In this case, the reuse of the same value in the <code>@y</code> and
              <code>@height</code> attributes means that the variable is not merely a matter of
            convenience, since that reuse also means that the same expression does not have to be
            evaluated more than once.</para>
        </footnote></para>
      <para>Convenience variables may play a role in pipelining when the result of one function is
        passed to another. For example,</para>
      <programlisting>&lt;xsl:value-of select="func2(func1($x))"/&gt;</programlisting>
      <para>may be rewritten as:</para>
      <programlisting>&lt;xsl:variable name="y" select="func1($x)"/&gt;
&lt;xsl:value-of select="func2($y)"&gt;</programlisting>
      <para>The difference between nesting explicit function syntax and nesting a variable
        containing the result of evaluating one function inside another function is discussed in
        greater detail below. The distinction between convenience variables and those that
        contribute to the quality of the code in ways that are not limited to human legibility is
        important because the costs and benefits of creating variables to hold intermediate values
        must take into consideration whether using the variable conveys advantages beyond
        convenience, that is, beyond the legibility that supports ease of maintenance.</para>
    </section>
    <section>
      <title>Nested functions</title>
      <!-- Chaining. Map -->
      <para>One of the most natural types of micropipelining involves the nesting of functions, as
        in the example earlier that combines <code>normalize-space()</code> and
          <code>upper-case()</code> by nesting one inside the other. This simple nested structure
        involves only two functions, each of which accepts only one parameter, but as the number of
        functions and the number of parameters grows, it is easy to lose one’s place in a thicket of
        parentheses. Consider, for example, a situation using the Wordhoard TEI edition of <emphasis
          role="ital">Hamlet</emphasis>,<footnote>
          <para><link>http://www.wwp.northeastern.edu/outreach/seminars/xslt_2012-03/demos/xslt_intro/ham.xml</link></para>
        </footnote> where our task is to construct a comma-separated list of distinct speakers (from
        the <code>&lt;speaker&gt;</code> element children of the <code>&lt;sp&gt;</code> speech
        elements) in Act 4. We can retrieve a deduplicated list of all &lt;speaker&gt; values with a
        single XPath function wrapped around a single path expressions:
          <code>distinct-values(//body/div[4]//speaker)</code>. The catch is that this list includes
        not only <quote>Rosencrantz</quote> and <quote>Guildenstern</quote>, both of whom speak
        alone, but also <quote>Rosencrantz and Guildenstern</quote> (as the string content of a
        single <code>&lt;speaker&gt;</code> element) where they speak in unison, and we like our
        result to recognize that <quote>Rosencrantz and Guildenstern</quote> is not a unique
        speaker. It is possible to perform the operation in a single line using nested
        functions:</para>
      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="2.0"
    xpath-default-namespace="http://www.tei-c.org/ns/1.0"&gt;
    &lt;xsl:output method="text"/&gt;
    &lt;xsl:template match="/"&gt;
        &lt;xsl:value-of
            select="distinct-values(tokenize(string-join(//body/div[4]//speaker/replace(., ' and ', ' '), ' '), '\s+'))"
        /&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
      <para>Here we pipe the output of the innermost <code>replace()</code> function into
          <code>string-join()</code>, and then into <code>tokenize()</code>, and then into
          <code>distinct-values()</code>.<footnote>
          <para>Replacing <quote> and </quote> with a space is a brittle strategy, since it would
            break on multiple-speaker values that were joined in different ways, such as
              <code>&lt;Curly, Larry, and Moe</code>. The point of the example is not find an
            optimal solution to the multiple-speaker problem, but to provide an example of
            pipelining functions.</para>
        </footnote> In favor of this strategy, nesting is the most direct possible representation of
        the pipeline relationship, since the input parameters to a function are included between the
        parentheses and the function statement evaluates to its output. Against this strategy, the
        depth of the nesting and the fact that several of the functions require multiple parameters
        greatly compromise the legibility, and thus the development and subsequent maintenance, of
        the code. Writing this code is messy and error-prone, and insofar as code is read much more
        often than it is written, nobody would regard it as easy to read. We might try to improve
        the legibility through indentation:</para>
      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="2.0"
    xpath-default-namespace="http://www.tei-c.org/ns/1.0"&gt;
    &lt;xsl:output method="text"/&gt;
    &lt;xsl:template match="/"&gt;
        &lt;xsl:value-of
            select="distinct-values(
                tokenize(
                    string-join(
                        //body/div[4]//speaker/replace(
                            .,
                            ' and ',
                            ' '
                        ),
                        ' '),
                    '\s+')
                )"
        /&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
      <para>although most developers would not consider this very legible either.<footnote>
          <para>Furthermore, it does not emerge unchanged when the stylesheet is pretty-printed in
            &lt;oXygen/&gt;, and probably in at least some other editors.</para>
        </footnote> There is good reason that the functional programming language Lisp, known for
        its deeply nested constructions, has been glossed humorously as <quote>Lots of Irritating
          Silly Parentheses</quote> and in other equivalent ways.<footnote>
          <para>see <link>https://xkcd.com/297/</link>. The name is actually derived from
              <quote>LISt Processor</quote>.</para>
        </footnote></para>
      <para>We can improve the legibility by rewriting this to use convenience variables:</para>
      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" exclude-result-prefixes="xs" version="2.0"
    xpath-default-namespace="http://www.tei-c.org/ns/1.0"&gt;
    &lt;xsl:output method="text"/&gt;
    &lt;xsl:template match="/"&gt;
        &lt;xsl:variable name="first" as="xs:string+"
            select="//body/div[4]//speaker/replace(., ' and ', ' ')"/&gt;
        &lt;xsl:variable name="second" as="xs:string" select="string-join($first, ' ')"/&gt;
        &lt;xsl:variable name="third" select="tokenize($second, '\s+')"/&gt;        
        &lt;xsl:variable name="fourth" as="xs:string+" select="distinct-values($third)"/&gt;
        &lt;xsl:sequence select="$fourth"/&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</programlisting>
      <para>This improvement comes at a price though. Much as the complexity of the compound
        operations makes it easy for a developer inadvertently to nest the functions incorrectly in
        the nested syntax, it is also easy to order them incorrectly in the version that employs
        convenience variables. A debugging fix that is simple to describe (<quote>revise the order
          in which the functions are applied</quote>, which might incorrectly suggest that this
        could be mapped onto <quote>rearrange the lines in which the variables are created</quote>)
        turns out to be error prone because each line refers to two variable names, the one it is
        creating with its <code>@name</code> attribute and the one that it is using to determine the
        value, which is part of the content of its <code>@select</code> attribute. Changes in the
        order in which the functions are executed thus becomes far more complex and error-prone than
        dragging the lines into a different order. One way to conceptualize the challenge is that
        the variable declarations exist in a feeding relationship not just by virtue of their order
        (although XSLT prohibits counterfeeding variable declarations), but also by virtue of the
        way each declaration uses a value created by a different declaration.</para>
      <para>Given that variables in XSLT cannot be redeclared, one might wonder why XSLT requires
        that sibling variable declarations within a stylesheet be declared in the order in which
        they are referenced. That is, one might wonder why XSLT prohibits ordering sibling
          <code>&lt;xsl:variable&gt;</code> elements in counter-feeding order. Whatever the reason
        for this restriction, it means that rearranging the order in which the functions are applied
        involves not only changing the references among them, but also modifying the order of the
          <code>&lt;xsl:variable&gt;</code> elements so that the order of declaration follows the
        order in which the values are used.</para>
      <para>One reason that deeply nested functions with multiple parameters are difficult to read
        is that code is written from left to right, which tacitly encourages humans to read it from
        left to right, but the feeding order (and thus the execution) of nested functions flows from
        the inside out. In languages that support object-oriented programming, the <emphasis
          role="bold">dotted method notation</emphasis> avoids this clash because both the notation
        and the execution flow from left to right. For example, the following Python example returns
        the same results as the XSLT above:<footnote>
          <para>To keep the focus on the pipelining code, the speaker names, as they appear in the
            act, are supplied as a Python list. In a real application they would be extracted from
            the XML using one of the several Python XML libraries.</para>
        </footnote></para>
      <programlisting>names = ['King','Gertrude','King','Gertrude','King','Gertrude','King','Hamlet','Rosencrantz and Guildenstern',\
         'Hamlet','Rosencrantz','Hamlet','Rosencrantz','Hamlet','Rosencrantz','Hamlet','Rosencrantz','Hamlet',\
         'Rosencrantz','Hamlet','Rosencrantz','Hamlet','Guildenstern','Hamlet','King','Rosencrantz','King',\
         'Rosencrantz','King','Rosencrantz','King','Hamlet','King','Hamlet','King','Hamlet','King','Hamlet','King',\
         'Hamlet','King','Hamlet','King','Hamlet','King','Hamlet','King','Hamlet','King','Hamlet','King','Fortinbras',\
         'Captain','Fortinbras','Hamlet','Captain','Hamlet','Captain','Hamlet','Captain','Hamlet','Captain','Hamlet',\
         'Captain','Hamlet','Captain','Rosencrantz','Hamlet','Gertrude','Gentleman','Gertrude','Gentleman','Horatio',\
         'Gertrude','Ophelia','Gertrude','Ophelia','Gertrude','Ophelia','Gertrude','Ophelia','Gertrude','Ophelia',\
         'King','Ophelia','King','Ophelia','King','Ophelia','King','Ophelia','King','Gertrude','King','Gentleman',\
         'Gertrude','King','Laertes','Danes','Laertes','Danes','Laertes','Gertrude','Laertes','King','Laertes','King',\
         'Gertrude','King','Laertes','King','Laertes','King','Laertes','King','Laertes','King','Danes','Laertes',\
         'Ophelia','Laertes','Ophelia','Laertes','Ophelia','Laertes','Ophelia','Laertes','Ophelia','Laertes','King',\
         'Laertes','King','Horatio','Servant','Horatio','Sailor','Horatio','Sailor','Horatio','King','Laertes','King',\
         'Laertes','King','Messenger','King','Messenger','King','Laertes','King','Laertes','King','Laertes','King',\
         'Laertes','King','Laertes','King','Laertes','King','Laertes','King','Laertes','King','Laertes','King',\
         'Laertes','King','Laertes','King','Laertes','King','Gertrude','Laertes','Gertrude','Laertes','Gertrude',\
         'Laertes','King']
result = set(' '.join(names).replace(' and ', ' ').split())
print(result)</programlisting>
      <para>The <code>set()</code> function is used to remove the duplicates and its input is
        contained in the parentheses that immediately follow the function name, but otherwise the
        order of execution and the syntactic expression both flow from left to right using dotted
        method notation: from <code>join()</code> (equivalent to XSLT <code>string-join()</code>)
        into <code>replace()</code> (also called <code>replace()</code> in XSLT) into
          <code>split()</code> (equivalent to <code>tokenize()</code> in XSLT).<footnote>
          <para>The syntax of the <code>join()</code> function <quote>appears to make some
              programmers feel uncomfortable</quote>.<xref linkend="python-join"/>
            <code>join()</code> is a method not of the list (the Python equivalent of an XSLT
            sequence, in this case the list of speaker names), but of the string separator (in this
            example, a space character), which suggests that the code is operating on the separator
            character and using the list to do it. The XSLT parameters order the sequence before the
            separator, which might suggest the reverse, that the function uses the separator to
            transform the sequence.</para>
        </footnote></para>
      <para>While dotted method notation is natural within an object-oriented model, the notation is
        not inherently incompatible with functional programming paradigms. Pipelines with dot
        notation when working within a function model in Python are supported by the PyFunctional
        package, which <quote>makes creating data pipelines easy by using chained functional
          operators.</quote><xref linkend="pyfunctional"/> XSLT nonetheless does not support a
        left-to-right function chaining notation, which means that if a pipeline of XSLT functions
        is to be expressed in a single line of code, it must be expressed through nesting, and must
        therefore operate from the inside out even though human coders might more instinctively read
        and write from the left to the right.</para>
    </section>
    <section>
      <title>Calling templates</title>
      <para>Stuff about calling templates</para>
    </section>
    <section>
      <title>The visitor pattern</title>
      <para>Stuff about the visitor pattern</para>
    </section>
    <section>
      <title>nested calls to the replace() functions</title>
      <para>Stuff about character-set conversion using table-driven sibling recursion with
        replace()</para>
    </section>
  </section>
  <section>
    <title>Conclusion</title>
    <para>Generalizations</para>
  </section>
  <section>
    <title>Stuff</title>
    <para>I read Michael's article with interest, and especially the observation that the processing
      quagmire isn't push or pull, but transitions (in either direction) between them. Michael
      writes about the inner workings of Saxon, with the idea of avoiding the overhead of creating
      intermediate structures by streaming that which is streamable. For the rest of us, though,
      although Michael advises us about how to write code that is capable of operating without
      building an interim tree in memory (or other inefficiencies), whether our code takes advantage
      of the potential for efficiency is largely inside the black box. And while Michael has put a
      window in the box, it still operates at a lower level, one that invites us to operate on its
      terms, but where only a Java programmer with access to the source code can control whether it
      turns our potentially efficient code into real efficiency. None of this problematic; it just
      reminds me that the end-user benefits from cooperating with the efficiencies available in the
      application, but ultimately optimization is out of our control.</para>
    <para>What I've been thinking of in connection with pipelining grows out of our earlier
      correspondence about the "visitor pattern" (which I had never heard of previously) and related
      issues. The challenge I was trying to address was that a single XSLT stylesheet affords
      several ways of building pipelines, each of which has its own advantages and disadvantages
      with respect to legibility and ease of use (for the coder), which are a higher priority for me
      than execution efficiency (see below). For example, function1(function2(function3(input)))
      invites misplaced punctuation, especially as the number of embedded functions grows and if any
      of the functions takes more than one argument. Template processing benefits from isolating
      each operation, similarly to functional decomposition, but it's difficult to see the entire
      pipeline at a glance. The visitor pattern that you recommended is more legible (and therefore
      manageable) than either of the alternatives, but it operates at an additional level of
      abstraction that keeps it from being intuitive (which is a solipsistic way of saying that it
      didn't occur to me as an option until you suggested it). Along a different thread that's part
      of the same garment, I often need to transform someone else's gnarly non-Unicode slop into
      Unicode, and the character mappings may be a combination of one-to-one, one-to-many,
      many-to-one, and many-to-many. Some of operations are critically ordered for reasons that in
      linguistics are termed "feeding" and "bleeding"; others can happen in any order. I've
      developed a table-driven approach for managing these types of transformations, which I don't
      consider especially profound or clever, but it does improve legibility over explicit nested
      function calls. The table-driven approach calls a replace() function by running sibling
      recursion on the mapping table (with a few details to accommodate order constraints), and the
      table is legible in the same way as the list of template invocations in the visitor strategy.
      My character-mapping operation finishes with the dynamic construction of arguments 2 and 3 to
      translate() to handle the one-to-one mappings at the end of the process; those could
      alternatively be handled by continuing the replace() pipeline, but translate() is more
      efficient, and it has other advantages for one-to-one mapping (such as the ability to do
      translate($stuff,'xy','yx') without having to create an intermediate representation to avoid
      unwanted feeding of one replacement into another.</para>
    <para>As I've been crafting bespoke solutions to these types of pipelining problems over the
      years, I've wished for a tutorial that would list the options, say something smart about the
      advantages and disadvantages of each, point out where they behave similarly or differently
      from one another, and perhaps make recommendations for deciding among them in the field. That
      tutorial is the vague target I had in mind for a Balisage submission. I was less interested in
      the scalability and streamability on which Michael focuses not only because I don't control
      what happens inside the black box, but also because in my world the data have never been so
      voluminous that my coffee has gotten cold while I waited for a transformation to run to
      completion. So while computational efficiency is self-evidently better than computational
      inefficiency, legibility is of more value to me, since otherwise I lose more time trying to
      understand my code than I lose running it.</para>
    <para>The essential principle of JSP was the idea that the structure of the program should
      mirror the structure of the data. (Kay 2009)</para>
  </section>
  <!-- Kay 2009: "Performance problems arise when components with different polarity are mixed within the same pipeline." -->
  <bibliography>
    <title>Works cited</title>
    <bibliomixed xml:id="cocoon" xreflabel="Cocoon">Apache Cocoon.
        <link>http://cocoon.apache.org/</link></bibliomixed>
    <bibliomixed xml:id="birnbaum_2015" xreflabel="Birnbaum 2015">Birnbaum, David J., and Elise
      Thorsen. <quote>Markup and meter: Using XML tools to teach a computer to think about
        versification.</quote> Presented at Balisage: The Markup Conference 2015, Washington, DC,
      August 11 - 14, 2015. In <emphasis role="ital">Proceedings of Balisage: The Markup Conference
        2015.</emphasis> Balisage Series on Markup Technologies, vol. 15 (2015). DOI:
      10.4242/BalisageVol15.Birnbaum01.
        <link>https://www.balisage.net/Proceedings/vol15/html/Birnbaum01/BalisageVol15-Birnbaum01.html</link></bibliomixed>
    <bibliomixed xml:id="fuller_2016" xreflabel="Fuller 2016">Fuller, James. <quote>A catalog of
        functional programming idioms in XQuery 3.1.</quote> Presented at <emphasis role="ital"
        >Balisage: The Markup Conference 2016, Washington, DC, August 2 - 5, 2016.</emphasis> In
      Proceedings of Balisage: The Markup Conference 2016. <emphasis role="ital">Balisage series on
        markup technologies,</emphasis> vol. 17 (2016). DOI: 10.4242/BalisageVol17.Fuller01.
        <link>https://www.balisage.net/Proceedings/vol17/html/Fuller01/BalisageVol17-Fuller01.html</link></bibliomixed>
    <bibliomixed xml:id="gamma_1994" xreflabel="Gamma 1994">Gamma, Erich, Richard Helm, Ralph
      Johnson, and John Vlissides. <quote>Design patterns: elements of reusable object-oriented
        software.</quote> Boston, MA: Addison-Wesley, 1994.</bibliomixed>
    <bibliomixed xml:id="kay_2008" xreflabel="Kay 2008">Kay, Michael, <emphasis role="ital">XSLT 2.0
        and XPath 2.0 programmer’s reference</emphasis>, 4th edition, Indianapolis: Wiley/Wrox,
      2008.</bibliomixed>
    <bibliomixed xml:id="kay_2009" xreflabel="Kay 2009">Kay, Michael. <quote>You pull, I’ll push: on
        the polarity of pipelines.</quote> Presented at <emphasis role="ital">Balisage: The Markup
        Conference 2009, Montréal, Canada, August 11 - 14, 2009.</emphasis> In <emphasis role="ital"
        >Proceedings of Balisage: The Markup Conference 2009. Balisage series on markup
        technologies, vol. 3 (2009). DOI: 10.4242/BalisageVol3.Kay01.</emphasis>
      <link>https://www.balisage.net/Proceedings/vol3/html/Kay01/BalisageVol3-Kay01.html</link></bibliomixed>
    <bibliomixed xml:id="kiparsky_1973" xreflabel="Kiparsky 1973">Kiparsky, Paul. Abstractness,
      opacity, and global rules. In , O. Fujimura, ed, <emphasis role="ital">Three dimensions of
        linguistic theory</emphasis>, pages 57–86. Tokyo: TEC, 1973.</bibliomixed>
    <bibliomixed xml:id="knuth_1974" xreflabel="Knuth 1974">Kunth, Donald E. <quote>Structured
        programming with <code>go to</code> statements</quote>, Computing surveys 6(4): 261–301.
        <link>http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf</link></bibliomixed>
    <bibliomixed xml:id="koenig_1995" xreflabel="Koenig 1995"><quote>Patterns and
        antipatterns.</quote>
      <emphasis role="ital">Journal of object-oriented programming</emphasis> 8(1): 46-48
      (1995)</bibliomixed>
    <bibliomixed xml:id="pyfunctional" xreflabel="PyFunctional">PyFunctional (Python package).
        (<link>https://github.com/EntilZha/PyFunctional</link>)</bibliomixed>
    <bibliomixed xml:id="mcilroy_1964" xreflabel="McIlroy 1964"><quote>The origin of Unix
        pipes,</quote> Bell Labs document archive.
      <link>http://doc.cat-v.org/unix/pipes/</link></bibliomixed>
    <bibliomixed xml:id="piez_2016" xreflabel="Piez 2016">Piez, Wendell. <quote>Framing the problem:
        building customized editing environments and workflows.</quote> Presented at <emphasis
        role="ital">Balisage: The Markup Conference 2016, Washington, DC, August 2 - 5,
        2016.</emphasis> In <emphasis role="ital">Proceedings of Balisage: The Markup Conference
        2016. Balisage series on markup technologies</emphasis>, vol. 17 (2016). DOI:
      10.4242/BalisageVol17.Piez01.
        <link>https://www.balisage.net/Proceedings/vol17/html/Piez01/BalisageVol17-Piez01.html</link></bibliomixed>
    <bibliomixed xml:id="python-join" xreflabel="Why"><quote>Why is join() a string method instead
        of a list or tuple method?</quote> Part of the <emphasis role="ital">[Python] Design and
        history FAQ.</emphasis>
      <link>https://docs.python.org/3/faq/design.html#why-is-join-a-string-method-instead-of-a-list-or-tuple-method</link>
    </bibliomixed>
    <bibliomixed xml:id="XProc" xreflabel="Xproc">XProc: An XML Pipeline Language.
        <link>https://xproc.org/</link></bibliomixed>
  </bibliography>
</article>
